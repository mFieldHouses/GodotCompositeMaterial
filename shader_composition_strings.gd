extends Node

#Yes, of course ChatGPT wrote this for me

const render_mode_shaded_string : String = 'shader_type spatial; render_mode cull_disabled, depth_prepass_alpha;'

const render_mode_unshaded_string : String = 'shader_type spatial; render_mode cull_disabled, depth_prepass_alpha, unshaded;'

const base_string : String = 'uniform int albedo_channel = 0; group_uniforms vertex_displacement; uniform int vertex_displacement_mode : hint_enum("Disabled", "Normal") = 0; uniform float vertex_displacement_scale = -1.0; uniform sampler2D vertex_displacement_map : hint_default_black; %parameters varying vec3 local_vertex_normal; varying vec3 global_vertex_normal; varying vec3 global_vertex_pos; varying vec3 local_vertex_pos; varying vec3 vertex_color; bool get_layer_enabled(int layer_index) { switch (layer_index) { %get_layer_enabled_sc } } vec2 get_layer_uv_offset(int layer, int uv_map_index, vec2 uv) { switch (layer) { %get_layer_uv_offset_sc } } vec2 get_layer_uv(int layer, int uv_map_index, vec2 uv) { switch (layer) { %get_layer_uv_sc } } int get_layer_map_uv_index(int layer, int map_index) { switch (layer) { %get_layer_map_uv_index_sc } } int get_layer_mask_mixing_step(int layer, int mask) { switch (layer) { %get_layer_mask_mixing_step_sc } } int get_layer_step_mixing_operation(int layer, int step) { switch (layer) { %get_layer_step_mixing_operation_sc } } float get_layer_step_mixing_threshold(int layer, int step) { switch (layer) { %get_layer_step_mixing_threshold_sc } } float get_layer_mask_amplification(int layer) { switch (layer) { %get_layer_mask_amplification_sc } } float get_layer_mask_post_color_ramp_value(int layer, float factor) { switch (layer) { %get_layer_mask_post_color_ramp_value_sc } } int get_layer_post_effect(int layer) { switch (layer) { %get_layer_post_effect_sc } } float get_layer_post_effect_parameter(int layer, int parameter_index) { switch (layer) { %get_layer_post_effect_parameter_sc } } vec4 get_layer_texture_mask_texture(int layer, int a_or_b, vec2 uv) { switch (layer) { %get_layer_texture_mask_texture_sc } } bool get_layer_texture_mask_enabled(int layer, int a_or_b) { switch (layer) { %get_layer_texture_mask_enabled_sc } } int get_layer_texture_masks_subtraction_order(int layer) { switch (layer) { %get_layer_texture_masks_subtraction_order_sc } } int get_layer_texture_mask_mix_operation(int layer) { switch (layer) { %get_layer_texture_mask_mix_operation_sc } } float get_layer_texture_mask_color_ramp_value(int layer, float factor, int a_or_b) { switch (layer) { %get_layer_texture_mask_color_ramp_value_sc } } int get_layer_directional_mask_mode(int layer) { switch (layer) { %get_layer_directional_mask_mode_sc } } int get_layer_directional_mask_space(int layer) { switch (layer) { %get_layer_directional_mask_space_sc } } float get_layer_directional_mask_color_ramp_value(int layer, float factor) { switch (layer) { %get_layer_directional_mask_color_ramp_value_sc } } int get_layer_positional_mask_mode(int layer) { switch (layer) { %get_layer_positional_mask_mode_sc } } int get_layer_positional_mask_axis(int layer) { switch (layer) { %get_layer_positional_mask_axis_sc } } float get_layer_positional_mask_min(int layer) { switch (layer) { %get_layer_positional_mask_min_sc } } float get_layer_positional_mask_max(int layer) { switch (layer) { %get_layer_positional_mask_max_sc } } float get_layer_positional_mask_color_ramp_value(int layer, float factor) { switch (layer) { %get_layer_positional_mask_color_ramp_value_sc } } int get_layer_vertex_color_mask_mode(int layer) { switch (layer) { %get_layer_vertex_color_mask_mode_sc } } float get_layer_vertex_color_mask_color_ramp_value(int layer, float factor) { switch (layer) { %get_layer_vertex_color_mask_color_ramp_value_sc } } int get_layer_normal_map_slope_mask_mode(int layer) { switch (layer) { %get_layer_normal_map_slope_mask_mode_sc } } float get_layer_normal_map_slope_mask_color_ramp_value(int layer, float factor) { switch (layer) { %get_layer_normal_map_slope_mask_color_ramp_value_sc } } bool get_layer_uv_mask_enabled(int layer) { switch (layer) { %get_layer_uv_mask_enabled_sc } } int get_layer_uv_mask_mixing_operation(int layer) { switch (layer) { %get_layer_uv_mask_mixing_operation_sc } } int get_layer_uv_mask_mixing_order(int layer) { switch (layer) { %get_layer_uv_mask_mixing_order_sc } } float get_layer_uv_mask_color_ramp_value(int layer, bool axis, float factor) { switch (layer) { %get_layer_uv_mask_color_ramp_value_sc } } float get_layer_uv_mask_min(int layer, bool axis) { switch (layer) { %get_layer_uv_mask_min_sc } } float get_layer_uv_mask_max(int layer, bool axis) { switch (layer) { %get_layer_uv_mask_max_sc } } float get_texture_mask_for_layer(int layer, vec2 mask_a_uv, vec2 mask_b_uv) { float texture_mask_mix; vec4 texture_mask_A_texture = get_layer_texture_mask_texture(layer, 0, mask_a_uv); vec4 texture_mask_B_texture = get_layer_texture_mask_texture(layer, 1, mask_b_uv); vec4 texture_mask_A_factor = vec4(get_layer_texture_mask_color_ramp_value(layer, texture_mask_A_texture.r, 0)); vec4 texture_mask_B_factor = vec4(get_layer_texture_mask_color_ramp_value(layer, texture_mask_B_texture.r, 1)); int texture_masks_subtraction_order = get_layer_texture_masks_subtraction_order(layer); bool texture_mask_A_enabled = get_layer_texture_mask_enabled(layer, 0); bool texture_mask_B_enabled = get_layer_texture_mask_enabled(layer, 1); switch (get_layer_texture_mask_mix_operation(layer)) { case 0: texture_mask_mix = (texture_mask_A_factor.r * texture_mask_A_factor.a * float(texture_mask_A_enabled)) + (texture_mask_B_factor.r * texture_mask_B_factor.a * float(texture_mask_B_enabled)); break; case 1: switch (texture_masks_subtraction_order) { case 0: texture_mask_mix = (texture_mask_A_factor.r * texture_mask_A_factor.a * float(texture_mask_A_enabled)) - (texture_mask_B_factor.r * texture_mask_B_factor.a * float(texture_mask_B_enabled)); break; case 1: texture_mask_mix = (texture_mask_B_factor.r * texture_mask_B_factor.a * float(texture_mask_B_enabled)) - (texture_mask_A_factor.r * texture_mask_A_factor.a * float(texture_mask_A_enabled)); break; } break; case 2: texture_mask_mix = texture_mask_A_factor.r * texture_mask_B_factor.r; break; } return texture_mask_mix; } float get_directional_mask_for_layer(int layer, vec3 local_surface_normal, vec3 global_surface_normal) { vec3 surface_normal = local_surface_normal * float(get_layer_directional_mask_space(layer) == 1) + global_surface_normal * float(get_layer_directional_mask_space(layer) == 0); switch (get_layer_directional_mask_mode(layer)) { case 0: return 0.0; case 1: return (abs(surface_normal.r) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.r))); case 2: return (clamp(surface_normal.r, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.r, 0.0, 1.0))); case 3: return (abs(clamp(surface_normal.r, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.r, -1.0, 0.0)))); case 4: return (abs(surface_normal.g) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.g))); case 5: return (clamp(surface_normal.g, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.g, 0.0, 1.0))); case 6: return (abs(clamp(surface_normal.g, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.g, -1.0, 0.0)))); case 7: return (abs(surface_normal.b) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.b))); case 8: return (clamp(surface_normal.b, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.b, 0.0, 1.0))); case 9: return (abs(clamp(surface_normal.b, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.b, -1.0, 0.0)))); } } float get_positional_mask_for_layer(int layer, vec3 local_v_position, vec3 global_v_position) { float positional_mask_value; float positional_mask_max = get_layer_positional_mask_max(layer); float positional_mask_min = get_layer_positional_mask_min(layer); vec3 v_position = (float(get_layer_positional_mask_mode(layer) == 1) * local_v_position) + (float(get_layer_positional_mask_mode(layer) == 2) * global_v_position); switch (get_layer_positional_mask_axis(layer)) { case 0: positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.x + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998); return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0); case 1: positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.y + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998); return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0); case 2: positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.z + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998); return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0); } } float get_vertex_color_mask_for_layer(int layer) { switch (get_layer_vertex_color_mask_mode(layer)) { case 0: return 0.0; case 1: return get_layer_vertex_color_mask_color_ramp_value(layer, vertex_color.r); case 2: return get_layer_vertex_color_mask_color_ramp_value(layer, vertex_color.g); case 3: return get_layer_vertex_color_mask_color_ramp_value(layer, vertex_color.b); } } float get_normal_map_slope_mask_for_layer(int layer, vec2 uv) { switch (layer) { %get_normal_map_slope_mask_for_layer_sc } } float get_uv_mask_for_layer(int layer, vec2 uv) { float x_max = get_layer_uv_mask_max(layer, false); float x_min = get_layer_uv_mask_min(layer, false); float x_factor = clamp(1.0/(x_max - x_min) * uv.x + (1.0 - 1.0/(x_max - x_min) * x_max), 0.002, 0.998); float x_value = get_layer_uv_mask_color_ramp_value(layer, false, x_factor); float y_max = get_layer_uv_mask_max(layer, true); float y_min = get_layer_uv_mask_min(layer, true); float y_factor = clamp(1.0/(y_max - y_min) * uv.y + (1.0 - 1.0/(y_max - y_min) * y_max), 0.002, 0.998); float y_value = get_layer_uv_mask_color_ramp_value(layer, true, y_factor); float result; switch (get_layer_uv_mask_mixing_operation(layer)) { case 0: result = y_value + x_value; case 1: switch (get_layer_uv_mask_mixing_order(layer)) { case 0: result = x_value - y_value; case 1: result = y_value - x_value; }; case 2: result = y_value * x_value; }; return result * float(get_layer_uv_mask_enabled(layer)); } float get_layer_mask_step_mix(int layer, int step, vec2 uv1, vec2 uv2, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position) { vec2 mask_a_uv = (uv1 * float(get_layer_map_uv_index(layer, 5) == 0) + uv2 * float(get_layer_map_uv_index(layer, 5) == 1)); vec2 mask_b_uv = (uv1 * float(get_layer_map_uv_index(layer, 6) == 0) + uv2 * float(get_layer_map_uv_index(layer, 6) == 1)); vec2 uv_mask_uv = (uv1 * float(get_layer_map_uv_index(layer, 7) == 0) + uv2 * float(get_layer_map_uv_index(layer, 7) == 1)); vec2 normal_map_uv = uv1 * float(get_layer_map_uv_index(layer, 0) == 0) + uv2 * float(get_layer_map_uv_index(layer, 0) == 1); return clamp((get_texture_mask_for_layer(layer, mask_a_uv, mask_b_uv) * float(get_layer_mask_mixing_step(layer, 1) == step) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == step) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == step) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == step) + get_normal_map_slope_mask_for_layer(layer, normal_map_uv) * float(get_layer_mask_mixing_step(layer, 5) == step) + get_uv_mask_for_layer(layer, uv_mask_uv) * float(get_layer_mask_mixing_step(layer, 6) == step)), 0.0, 1.0); } float get_resulting_mask_for_layer(int layer, vec2 uv1, vec2 uv2, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position) { float step_1_mix = get_layer_mask_step_mix(layer, 1, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position); float step_2_mix = get_layer_mask_step_mix(layer, 2, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position); switch (get_layer_step_mixing_operation(layer, 2)) { case 0: step_2_mix = clamp(step_1_mix + (step_2_mix * float(step_1_mix >= get_layer_step_mixing_threshold(layer, 2))), 0.0, 1.0); break; case 1: step_2_mix = clamp(step_1_mix - (step_2_mix * float(step_1_mix >= get_layer_step_mixing_threshold(layer, 2))), 0.0, 1.0); break; case 2: if (step_1_mix >= get_layer_step_mixing_threshold(layer, 2)) { step_2_mix = clamp(step_1_mix * step_2_mix, 0.0, 1.0); } else { step_2_mix = step_1_mix; } break; } float step_3_mix = get_layer_mask_step_mix(layer, 3, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position); switch (get_layer_step_mixing_operation(layer, 3)) { case 0: step_3_mix = clamp(step_2_mix + (step_3_mix * float(step_2_mix >= get_layer_step_mixing_threshold(layer, 3))), 0.0, 1.0); break; case 1: step_3_mix = clamp(step_2_mix - (step_3_mix * float(step_2_mix >= get_layer_step_mixing_threshold(layer, 3))), 0.0, 1.0); break; case 2: if (step_2_mix >= get_layer_step_mixing_threshold(layer, 3)) { step_3_mix = clamp(step_2_mix * step_3_mix, 0.0, 1.0); } else { step_3_mix = step_2_mix; } break; } float step_4_mix = get_layer_mask_step_mix(layer, 4, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position); switch (get_layer_step_mixing_operation(layer, 4)) { case 0: step_4_mix = clamp(step_3_mix + (step_4_mix * float(step_3_mix >= get_layer_step_mixing_threshold(layer, 4))), 0.0, 1.0); break; case 1: step_4_mix = clamp(step_3_mix - (step_4_mix * float(step_3_mix >= get_layer_step_mixing_threshold(layer, 4))), 0.0, 1.0); break; case 2: if (step_3_mix >= get_layer_step_mixing_threshold(layer, 4)) { step_4_mix = clamp(step_3_mix * step_4_mix, 0.0, 1.0); } else { step_4_mix = step_3_mix; } break; } float step_5_mix = get_layer_mask_step_mix(layer, 5, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position); switch (get_layer_step_mixing_operation(layer, 5)) { case 0: step_5_mix = clamp(step_4_mix + (step_5_mix * float(step_4_mix >= get_layer_step_mixing_threshold(layer, 5))), 0.0, 1.0); break; case 1: step_5_mix = clamp(step_4_mix - (step_5_mix * float(step_4_mix >= get_layer_step_mixing_threshold(layer, 5))), 0.0, 1.0); break; case 2: if (step_4_mix >= get_layer_step_mixing_threshold(layer, 5)) { step_5_mix = clamp(step_4_mix * step_5_mix, 0.0, 1.0); } else { step_5_mix = step_4_mix; } break; } float step_6_mix = get_layer_mask_step_mix(layer, 6, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position); switch (get_layer_step_mixing_operation(layer, 6)) { case 0: step_6_mix = clamp(step_4_mix + (step_6_mix * float(step_5_mix >= get_layer_step_mixing_threshold(layer, 6))), 0.0, 1.0); break; case 1: step_6_mix = clamp(step_4_mix - (step_6_mix * float(step_5_mix >= get_layer_step_mixing_threshold(layer, 6))), 0.0, 1.0); break; case 2: if (step_5_mix >= get_layer_step_mixing_threshold(layer, 6)) { step_6_mix = clamp(step_5_mix * step_6_mix, 0.0, 1.0); } else { step_6_mix = step_5_mix; } break; } switch (get_layer_post_effect(layer)) { case 1: step_6_mix = step_6_mix + 0.1; case 2: step_6_mix = 0.0; }; return get_layer_mask_post_color_ramp_value(layer, clamp(step_5_mix, 0.0, 1.0) * get_layer_mask_amplification(layer) + 0.002); } void vertex() { switch (vertex_displacement_mode) { case 1: VERTEX.xyz += NORMAL.xyz * vertex_displacement_scale * texture(vertex_displacement_map, UV).r; break; } local_vertex_normal = NORMAL.rgb; global_vertex_normal = local_vertex_normal * MODEL_NORMAL_MATRIX; local_vertex_pos = VERTEX.xyz; global_vertex_pos = (vec4(local_vertex_normal, 1.0) * MODEL_MATRIX).xyz; } void fragment() { vertex_color = COLOR.rgb; vec3 albedo_mix = vec3(0.0, 0.0, 0.0); float occlusion_mix = 0.0; float roughness_mix = 0.5; float metallic_mix = 0.0; vec3 normal_mix = vec3(0.5, 1.0, 0.5); %layer_fragment_snippets switch (albedo_channel) { case 0: ALBEDO = albedo_mix.rgb; break; case 1: ALBEDO = vec3(roughness_mix); break; case 2: ALBEDO = vec3(metallic_mix); break; case 3: ALBEDO = normal_mix; break; }; ROUGHNESS = roughness_mix; METALLIC = metallic_mix; NORMAL_MAP = normal_mix; }'

const parameters_string : String = 'group_uniforms layer_%s; uniform bool layer_%s_enabled = true; uniform sampler2D layer_%s_albedo : source_color, hint_default_transparent; uniform sampler2D layer_%s_normal : hint_normal; uniform bool layer_%s_propagate_normals = false; uniform vec2 layer_%s_uv1_scale = vec2(1.0); uniform vec2 layer_%s_uv1_offset = vec2(0.0); uniform sampler2D layer_%s_uv1_offset_map : hint_default_transparent, filter_nearest; uniform vec2 layer_%s_uv1_offset_map_scale = vec2(1.0, 1.0); uniform float layer_%s_uv1_offset_map_factor = 1.0; uniform vec2 layer_%s_uv2_scale = vec2(1.0); uniform vec2 layer_%s_uv2_offset = vec2(0.0); uniform sampler2D layer_%s_uv2_offset_map : hint_default_transparent, filter_nearest; uniform vec2 layer_%s_uv2_offset_map_scale = vec2(1.0, 1.0); uniform float layer_%s_uv2_offset_map_factor = 1.0; uniform int layer_%s_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1; uniform int layer_%s_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1; uniform int layer_%s_UV_mask_UV_assignment : hint_enum("UV1", "UV2") = 0; uniform int layer_%s_orm_mode : hint_enum("Single map", "Seperate maps") = 0; uniform sampler2D layer_%s_orm_map : hint_default_transparent; uniform sampler2D layer_%s_occlusion_map : hint_default_transparent; uniform sampler2D layer_%s_roughness_map : hint_default_transparent; uniform sampler2D layer_%s_metallic_map : hint_default_transparent; uniform bool layer_%s_consolidate_masks = false; uniform float layer_%s_mask_amplification : hint_range(0.0, 10.0) = 1.0; uniform int layer_%s_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0; uniform float layer_%s_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0; uniform int layer_%s_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0; uniform float layer_%s_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0; uniform int layer_%s_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0; uniform float layer_%s_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0; uniform int layer_%s_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0; uniform float layer_%s_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0; uniform int layer_%s_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0; uniform float layer_%s_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0; uniform sampler2D layer_%s_post_color_ramp : hint_default_transparent; uniform int layer_%s_post_effect : hint_enum("None", "Drip", "Expand-Blur") = 0; uniform float layer_%s_post_effect_parameter_1 : hint_range(0.0, 1.0) = 0.1; uniform float layer_%s_post_effect_parameter_2 = 0.0; uniform float layer_%s_post_effect_parameter_3 = 0.0; uniform bool layer_%s_texture_mask_A_enabled = true; uniform sampler2D layer_%s_texture_mask_A : hint_default_transparent; uniform sampler2D layer_%s_texture_mask_A_color_ramp : hint_default_transparent; uniform bool layer_%s_texture_mask_B_enabled = false; uniform sampler2D layer_%s_texture_mask_B : hint_default_transparent; uniform sampler2D layer_%s_texture_mask_B_color_ramp : hint_default_transparent; uniform int layer_%s_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0; uniform int layer_%s_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0; uniform int layer_%s_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 1; uniform int layer_%s_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-"); uniform int layer_%s_directional_mask_space : hint_enum("Global", "Local") = 0; uniform sampler2D layer_%s_directional_mask_color_ramp : hint_default_transparent; uniform int layer_%s_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 2; uniform int layer_%s_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0; uniform sampler2D layer_%s_positional_mask_color_ramp : hint_default_transparent; uniform int layer_%s_positional_mask_axis : hint_enum("X", "Y", "Z") = 1; uniform float layer_%s_positional_mask_max = 1.0; uniform float layer_%s_positional_mask_min = -1.0; uniform int layer_%s_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 3; uniform int layer_%s_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0; uniform sampler2D layer_%s_vertex_color_mask_color_ramp : hint_default_transparent; uniform int layer_%s_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 4; uniform int layer_%s_normal_map_slope_mask_mode : hint_enum("Disabled", "Pre-Mask", "Post-Mask") = 0; uniform int layer_%s_normal_map_slope_mask_source : hint_enum("Previous Layer", "Current Layer") = 0; uniform sampler2D layer_%s_normal_map_slope_mask_color_ramp : hint_default_transparent; uniform int layer_%s_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5; uniform bool layer_%s_UV_mask_enabled = false; uniform int layer_%s_UV_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 6; uniform float layer_%s_UV_mask_X_min = 0.0; uniform float layer_%s_UV_mask_X_max = 1.0; uniform sampler2D layer_%s_UV_mask_X_color_ramp : hint_default_transparent; uniform float layer_%s_UV_mask_Y_min = 0.0; uniform float layer_%s_UV_mask_Y_max = 1.0; uniform sampler2D layer_%s_UV_mask_Y_color_ramp : hint_default_transparent; uniform int layer_%s_UV_mask_XY_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0; uniform int layer_%s_UV_mask_XY_mixing_order : hint_enum("X-Y", "Y-X") = 0;'

const fragment_snippet_string : String = 'if (layer_%s_enabled == true) { vec2 uv1 = (UV + get_layer_uv_offset(%s, 0, UV) + layer_%s_uv1_offset) * layer_%s_uv1_scale; vec2 uv2 = (UV + get_layer_uv_offset(%s, 1, UV) + layer_%s_uv2_offset) * layer_%s_uv2_scale; int layer_%s_normal_uv_map_index = get_layer_map_uv_index(%s,0); int layer_%s_albedo_uv_map_index = get_layer_map_uv_index(%s,1); int layer_%s_occlusion_uv_map_index = get_layer_map_uv_index(%s,2); int layer_%s_roughness_uv_map_index = get_layer_map_uv_index(%s,3); int layer_%s_metallic_uv_map_index = get_layer_map_uv_index(%s,4); vec4 layer_%s_albedo_texture = texture(layer_%s_albedo, uv1 * float(layer_%s_albedo_uv_map_index == 0) + uv2 * float(layer_%s_albedo_uv_map_index == 1)); vec2 layer_%s_occlusion_factor = texture(layer_%s_occlusion_map, uv1 * float(layer_%s_occlusion_uv_map_index == 0) + uv2 * float(layer_%s_occlusion_uv_map_index == 1)).ra * float(layer_%s_orm_mode) + texture(layer_%s_orm_map, uv1 * float(layer_%s_occlusion_uv_map_index == 0) + uv2 * float(layer_%s_occlusion_uv_map_index == 1)).ra * (1.0 - float(layer_%s_orm_mode)); vec2 layer_%s_roughness_factor = texture(layer_%s_roughness_map, uv1 * float(layer_%s_roughness_uv_map_index == 0) + uv2 * float(layer_%s_roughness_uv_map_index == 1)).ra * float(layer_%s_orm_mode) + texture(layer_%s_orm_map, uv1 * float(layer_%s_roughness_uv_map_index == 0) + uv2 * float(layer_%s_roughness_uv_map_index == 1)).ga * (1.0 - float(layer_%s_orm_mode)); vec2 layer_%s_metallic_factor = texture(layer_%s_metallic_map, uv1 * float(layer_%s_metallic_uv_map_index == 0) + uv2 * float(layer_%s_metallic_uv_map_index == 1)).ra * float(layer_%s_orm_mode) + texture(layer_%s_orm_map, uv1 * float(layer_%s_metallic_uv_map_index == 0) + uv2 * float(layer_%s_metallic_uv_map_index == 1)).ra * (1.0 - float(layer_%s_orm_mode)); vec3 layer_%s_normal_map = texture(layer_%s_normal, uv1 * float(layer_%s_normal_uv_map_index == 0) + uv2 * float(layer_%s_normal_uv_map_index == 1)).rgb; int mask_A_uv_map_index = get_layer_map_uv_index(%s, 5); int mask_B_uv_map_index = get_layer_map_uv_index(%s, 6); float layer_%s_mask_factor = get_resulting_mask_for_layer(%s, uv1, uv2, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos); albedo_mix = mix(albedo_mix, layer_%s_albedo_texture.rgb, layer_%s_mask_factor * layer_%s_albedo_texture.a); albedo_mix = mix(albedo_mix, vec3(layer_%s_mask_factor), float(layer_%s_consolidate_masks)); occlusion_mix = mix(occlusion_mix, layer_%s_occlusion_factor.x, layer_%s_mask_factor * layer_%s_occlusion_factor.y); roughness_mix = mix(roughness_mix, layer_%s_roughness_factor.x, layer_%s_mask_factor * layer_%s_roughness_factor.y); metallic_mix = mix(metallic_mix, layer_%s_metallic_factor.x, layer_%s_mask_factor * layer_%s_metallic_factor.y); normal_mix = mix(normal_mix, layer_%s_normal_map, layer_%s_mask_factor * (1.0 - float(layer_%s_propagate_normals))); float alpha_factor = layer_%s_mask_factor * layer_%s_albedo_texture.a; if (ALPHA < alpha_factor) { ALPHA = alpha_factor; } }'

const get_layer_enabled_string : String = 'return layer_%s_enabled;';

const get_layer_uv_offset_string : String = 'return ((texture(layer_%s_uv1_offset_map, uv * layer_%s_uv1_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_%s_uv1_offset_map, uv).a * layer_%s_uv1_offset_map_factor * float(uv_map_index == 0) + ((texture(layer_%s_uv2_offset_map, uv * layer_%s_uv2_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_%s_uv2_offset_map, uv).a * layer_%s_uv2_offset_map_factor * float(uv_map_index == 1);';

const get_layer_uv_string : String = 'return (uv + get_layer_uv_offset(%s, 0, uv) + layer_%s_uv1_offset) * layer_%s_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(%s, 1, uv) + layer_%s_uv2_offset) * layer_%s_uv2_scale * float(uv_map_index == 1);'

const get_layer_map_uv_index_string : String = 'return layer_%s_normal_map_UV_assignment * int(map_index == 0) + layer_%s_albedo_map_UV_assignment * int(map_index == 1) + layer_%s_occlusion_map_UV_assignment * int(map_index == 2) + layer_%s_roughness_map_UV_assignment * int(map_index == 3) + layer_%s_metallic_map_UV_assignment * int(map_index == 4) + layer_%s_UV_offset_map_UV_assignment * int(map_index == 5) + layer_%s_texture_mask_A_UV_assignment * int(map_index == 6) + layer_%s_texture_mask_B_UV_assignment * int(map_index == 7) + layer_%s_UV_mask_UV_assignment * int(map_index == 8);';

const get_layer_mask_mixing_step_string : String = 'return (layer_%s_texture_masks_mixing_step * int(mask == 1) + layer_%s_directional_mask_mixing_step * int(mask == 2) + layer_%s_positional_mask_mixing_step * int(mask == 3) + layer_%s_vertex_color_mask_mixing_step * int(mask == 4) + layer_%s_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_%s_UV_mask_mixing_step * int(mask == 6));';

const get_layer_step_mixing_operation_string : String = 'return (layer_%s_step_2_mixing_operation * int(step == 2) + layer_%s_step_3_mixing_operation * int(step == 3) + layer_%s_step_4_mixing_operation * int(step == 4) + layer_%s_step_5_mixing_operation * int(step == 5));';

const get_layer_step_mixing_threshold_string : String = 'return (layer_%s_step_2_mixing_threshold * float(step == 2) + layer_%s_step_3_mixing_threshold * float(step == 3) + layer_%s_step_4_mixing_threshold * float(step == 4) + layer_%s_step_5_mixing_threshold * float(step == 5));';

const get_layer_mask_amplification_string : String = 'return layer_%s_mask_amplification;';

const get_layer_mask_post_color_ramp_value_string : String = 'vec2 color_ramp_factor = texture(layer_%s_post_color_ramp, vec2((factor * 0.98) + 0.01, 0.0)).ra; return mix(factor, color_ramp_factor.x, color_ramp_factor.y);';

const get_layer_post_effect_string : String = 'return layer_%s_post_effect;';

const get_layer_post_effect_parameter_string : String = 'return layer_%s_post_effect_parameter_1 * float(parameter_index == 1) + layer_%s_post_effect_parameter_2 * float(parameter_index == 2) + layer_%s_post_effect_parameter_3 * float(parameter_index == 3);';

const get_layer_texture_mask_texture_string : String = 'return (texture(layer_%s_texture_mask_A, uv) * (1.0 - float(a_or_b))) + (texture(layer_%s_texture_mask_B, uv) * float(a_or_b));';

const get_layer_texture_mask_enabled_string : String = 'return layer_%s_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_%s_texture_mask_B_enabled && (bool(a_or_b) == true);';

const get_layer_texture_masks_subtraction_order_string : String = 'return layer_%s_texture_masks_subtraction_order;';

const get_layer_texture_mask_mix_operation_string : String = 'return layer_%s_texture_masks_mix_operation;';

const get_layer_texture_mask_color_ramp_value_string : String = 'vec2 color_ramp_factor = texture(layer_%s_texture_mask_A_color_ramp, vec2((factor * 0.98) + 0.01)).ra * float(a_or_b == 0) + texture(layer_%s_texture_mask_B_color_ramp, vec2((factor * 0.98) + 0.01)).ra * float(a_or_b); return mix(factor, color_ramp_factor.x, color_ramp_factor.y);'

const get_layer_directional_mask_mode_string : String = 'return layer_%s_directional_mask_mode;';

const get_layer_directional_mask_space_string : String = 'return layer_%s_directional_mask_space;';

const get_layer_directional_mask_color_ramp_value_string : String = 'vec2 color_ramp_factor = texture(layer_%s_directional_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0.0)).ra; return mix(factor, color_ramp_factor.x, color_ramp_factor.y);';

const get_layer_positional_mask_axis_string : String = 'return layer_%s_positional_mask_axis;';

const get_layer_positional_mask_mode_string : String = 'return layer_%s_positional_mask_mode;'

const get_layer_positional_mask_min_string : String = 'return layer_%s_positional_mask_min;';

const get_layer_positional_mask_max_string : String = 'return layer_%s_positional_mask_max;';

const get_layer_positional_mask_color_ramp_value_string : String = 'vec2 color_ramp_factor = texture(layer_%s_positional_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0.0)).ra; return mix(factor, color_ramp_factor.x, color_ramp_factor.y);';

const get_layer_vertex_color_mask_mode_string : String = 'return layer_%s_vertex_color_mask_mode;'

const get_layer_vertex_color_mask_color_ramp_value_string : String = 'vec4 color_ramp_color = texture(layer_%s_vertex_color_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0)); return mix(factor, color_ramp_color.r, color_ramp_color.a);'

const get_layer_normal_map_slope_mask_min_string : String = 'return layer_%s_normal_map_slope_mask_min;';

const get_layer_normal_map_slope_mask_max_string : String = 'return layer_%s_normal_map_slope_mask_max;';

const get_layer_normal_map_slope_mask_mode_string : String = 'return layer_%s_normal_map_slope_mask_mode;'

const get_layer_normal_map_slope_mask_axis_string : String = 'return layer_%s_normal_map_slope_mask_axis;';

const get_normal_map_slope_mask_for_layer_string : String = 'vec4 normal_map_value = texture(layer_%s_normal, uv); float mask_value = (abs(normal_map_value.r - 0.5) * float(abs(normal_map_value.r - 0.5) > abs(normal_map_value.g - 0.5)) + abs(normal_map_value.g - 0.5) * float(abs(normal_map_value.r - 0.5) < abs(normal_map_value.g - 0.5))) * float(get_layer_normal_map_slope_mask_mode(1) != 0); return get_layer_normal_map_slope_mask_color_ramp_value(1, mask_value);'

const get_layer_normal_map_slope_mask_color_ramp_value_string : String = 'vec2 color_ramp_factor = texture(layer_%s_normal_map_slope_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0.0)).ra; return mix(factor, color_ramp_factor.x, color_ramp_factor.y);';

const get_layer_UV_mask_enabled_string : String = 'return layer_%s_UV_mask_enabled;';

const get_layer_UV_mask_mixing_operation_string : String = 'return layer_%s_UV_mask_XY_mixing_operation;'

const get_layer_UV_mask_mixing_order_string : String = 'return layer_%s_UV_mask_XY_mixing_order;'

const get_layer_UV_mask_min_string : String = 'return layer_%s_UV_mask_X_min * float(int(axis) == 0) + layer_%s_UV_mask_Y_min * float(int(axis) == 1);';

const get_layer_UV_mask_max_string : String = 'return layer_%s_UV_mask_X_max * float(int(axis) == 0) + layer_%s_UV_mask_Y_max * float(int(axis) == 1);';

const get_layer_UV_mask_color_ramp_value_string : String = 'vec4 color_ramp_color = texture(layer_%s_UV_mask_X_color_ramp, vec2((factor * 0.98) + 0.01, 0)) * float(int(axis) == 0) + texture(layer_%s_UV_mask_Y_color_ramp, vec2((factor * 0.98) + 0.01, 0)) * float(int(axis) == 1); return mix(factor, color_ramp_color.r, color_ramp_color.a);';
