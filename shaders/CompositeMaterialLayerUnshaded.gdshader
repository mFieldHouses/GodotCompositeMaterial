shader_type spatial;

//Todo: triplanar mapping, vertex displacement normal recalculation, implement changing order of layers (bottom, middle, top), uv rotation by uv offset map r channel, uv mask

render_mode cull_disabled, depth_prepass_alpha;

//indeces/enums:
//
//	maps/textures:
// 		0:normal
// 		1:albedo
// 		2:occlusion
// 		3:roughness
//		4:metallic
//		5:texture mask A
//		6:texture mask B
//      7:UV Mask

uniform int vertex_displacement_mode : hint_enum("Disabled", "Normal") = 0;
uniform float vertex_displacement_scale = -1.0;
uniform sampler2D vertex_displacement_map : hint_default_black;

/**
 * Whether this layer will display at all.
 */
uniform bool enabled = true;

uniform sampler2D albedo : source_color, hint_default_transparent;

uniform sampler2D normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool propagate_normals = false;

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 uv1_scale = vec2(1.0);
uniform vec2 uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D uv1_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float uv1_offset_map_factor = 1.0;

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 uv2_scale = vec2(1.0);
uniform vec2 uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D uv2_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float uv2_offset_map_factor = 1.0;

uniform int normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int UV_mask_UV_assignment : hint_enum("UV1", "UV2") = 0;

uniform int orm_mode : hint_enum("Single map", "Seperate maps") = 0;
uniform sampler2D orm_map : hint_default_transparent;
uniform sampler2D occlusion_map : hint_default_transparent;
uniform sampler2D roughness_map : hint_default_transparent;
uniform sampler2D metallic_map : hint_default_transparent;

/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask will be multiplied.
 */
uniform float mask_amplification : hint_range(0.0, 10.0) = 1.0;

/**
 * By what type of operation step 1 and step 2 will be mixed.
 */
uniform int step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * From which mask value on the masks assigned to step 1, step 1 and step 2 will mix.
 */
uniform float step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D post_color_ramp : hint_default_transparent;
uniform int post_effect : hint_enum("None", "Drip", "Expand-Blur") = 0;
uniform float post_effect_parameter_1 : hint_range(0.0, 1.0) = 0.1;
uniform float post_effect_parameter_2 = 0.0;
uniform float post_effect_parameter_3 = 0.0;

uniform bool texture_mask_A_enabled = true;
uniform sampler2D texture_mask_A : hint_default_transparent;
uniform bool texture_mask_B_enabled = false;
uniform sampler2D texture_mask_B : hint_default_transparent;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 1;

/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D directional_mask_color_ramp : hint_default_transparent;
uniform int directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 2;

uniform int positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D positional_mask_color_ramp : hint_default_transparent;
uniform int positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 3;

/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D vertex_color_mask_color_ramp : hint_default_transparent;
uniform int vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 4;

uniform int normal_map_slope_mask_mode : hint_enum("Disabled", "Pre-Mask", "Post-Mask") = 0;
uniform int normal_map_slope_mask_source : hint_enum("Previous Layer", "Current Layer") = 0;
uniform sampler2D normal_map_slope_mask_color_ramp : hint_default_transparent;
uniform int normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5;

uniform bool UV_mask_enabled = false;
uniform int UV_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 6;
uniform float UV_mask_X_min = 0.0;
uniform float UV_mask_X_max = 1.0;
uniform sampler2D UV_mask_X_color_ramp : hint_default_transparent;
uniform float UV_mask_Y_min = 0.0;
uniform float UV_mask_Y_max = 1.0;
uniform sampler2D UV_mask_Y_color_ramp : hint_default_transparent;
uniform int UV_mask_XY_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform int UV_mask_XY_mixing_order : hint_enum("X-Y", "Y-X") = 0;

// uniform vec3 previous_normal;
// uniform vec

varying vec3 local_vertex_normal;
varying vec3 global_vertex_normal;
varying vec3 global_vertex_pos;
varying vec3 local_vertex_pos;
varying vec3 vertex_color;



//==========================================================================


//==========================================================================




vec2 get_uv_offset(int uv_map_index, vec2 uv) {
	return ((texture(uv1_offset_map, uv * uv1_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(uv1_offset_map, uv).a * uv1_offset_map_factor * float(uv_map_index == 0) + ((texture(uv2_offset_map, uv * uv2_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(uv2_offset_map, uv).a * uv2_offset_map_factor * float(uv_map_index == 1);
}

vec2 get_uv(int uv_map_index, vec2 uv) {
	return (uv + get_uv_offset(0, uv) + uv1_offset) * uv1_scale * float(uv_map_index == 0) + (uv + get_uv_offset(1, uv) + uv2_offset) * uv2_scale * float(uv_map_index == 1);
}

int get_map_uv_index(int map_index) {
	switch (map_index) {
		case 0:
			return normal_map_UV_assignment;
		case 1:
			return albedo_map_UV_assignment;
		case 2:
			return occlusion_map_UV_assignment;
		case 3:
			return roughness_map_UV_assignment;
		case 4:
			return metallic_map_UV_assignment;
		case 5:
			return texture_mask_A_UV_assignment;
		case 6:
			return texture_mask_B_UV_assignment;
		case 7:
			return UV_mask_UV_assignment;
	}
}

int get_mask_mixing_step(int mask) {
	return (texture_masks_mixing_step * int(mask == 1) + directional_mask_mixing_step * int(mask == 2) + positional_mask_mixing_step * int(mask == 3) + vertex_color_mask_mixing_step * int(mask == 4) + normal_map_slope_mask_mixing_step * int(mask == 5) + UV_mask_mixing_step * int(mask == 6));
}

int get_step_mixing_operation(int step) {
	return (step_2_mixing_operation * int(step == 2) + step_3_mixing_operation * int(step == 3) + step_4_mixing_operation * int(step == 4) + step_5_mixing_operation * int(step == 5));
}

float get_step_mixing_threshold(int step) {
	return (step_2_mixing_threshold * float(step == 2) + step_3_mixing_threshold * float(step == 3) + step_4_mixing_threshold * float(step == 4) + step_5_mixing_threshold * float(step == 5));
}

float get_mask_post_color_ramp_value(float factor) {
	vec2 color_ramp_factor = texture(post_color_ramp, vec2(factor, 0.0)).ra;
	return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
}

// float get_layer_post_effect_parameter(int layer, int parameter_index) {
// 	switch (layer) {
// 		case 1:
// 			return layer_A_post_effect_parameter_1 * float(parameter_index == 1) + layer_A_post_effect_parameter_2 * float(parameter_index == 2) + layer_A_post_effect_parameter_3 * float(parameter_index == 3);
// 		case 2:
// 			return layer_B_post_effect_parameter_1 * float(parameter_index == 1) + layer_B_post_effect_parameter_2 * float(parameter_index == 2) + layer_B_post_effect_parameter_3 * float(parameter_index == 3);
// 		case 3:
// 			return layer_C_post_effect_parameter_1 * float(parameter_index == 1) + layer_C_post_effect_parameter_2 * float(parameter_index == 2) + layer_C_post_effect_parameter_3 * float(parameter_index == 3);
// 	}
// }

float get_directional_mask_color_ramp_value(float factor) {
	vec2 color_ramp_factor = texture(directional_mask_color_ramp, vec2((factor * 0.95) + 0.025)).ra;
	return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
}

float get_positional_mask_color_ramp_value(float factor) {
	vec2 color_ramp_factor = texture(positional_mask_color_ramp, vec2(factor, 0.0)).ra;
	return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
}

float get_normal_map_slope_mask_color_ramp_value(float factor) {
	vec4 color_ramp_color = texture(normal_map_slope_mask_color_ramp, vec2(factor, 0));
	return mix(factor, color_ramp_color.r, color_ramp_color.a);
}

//======================================================================




float get_texture_mask(vec2 mask_a_uv, vec2 mask_b_uv) {
	float texture_mask_mix;

	vec4 texture_mask_A_texture = texture(texture_mask_A, mask_a_uv);
	vec4 texture_mask_B_texture = texture(texture_mask_B, mask_b_uv);

	int texture_masks_AB_subtraction_order = texture_masks_subtraction_order;

	switch (texture_masks_mix_operation) {
		case 0:
			texture_mask_mix = (texture_mask_A_texture.r * texture_mask_A_texture.a * float(texture_mask_A_enabled)) + (texture_mask_B_texture.r * texture_mask_B_texture.a * float(texture_mask_B_enabled));
			break;
		case 1:
			switch (texture_masks_AB_subtraction_order) {
				case 0:
					texture_mask_mix = (texture_mask_A_texture.r * texture_mask_A_texture.a * float(texture_mask_A_enabled)) - (texture_mask_B_texture.r * texture_mask_B_texture.a * float(texture_mask_B_enabled));
					break;
				case 1:
					texture_mask_mix = (texture_mask_B_texture.r * texture_mask_B_texture.a * float(texture_mask_B_enabled)) - (texture_mask_A_texture.r * texture_mask_A_texture.a * float(texture_mask_A_enabled));
					break;
			}
			break;
		case 2:
			texture_mask_mix = texture_mask_A_texture.r * texture_mask_B_texture.r;
			break;
	}

	return texture_mask_mix;
}

float get_directional_mask(vec3 local_surface_normal, vec3 global_surface_normal) {
		vec3 surface_normal = local_surface_normal * float(directional_mask_space == 1) + global_surface_normal * float(directional_mask_space == 0);
		switch (directional_mask_mode) {
			case 0:
				return 0.0;
			case 1:
				return (abs(surface_normal.r) * get_directional_mask_color_ramp_value(abs(surface_normal.r)));
			case 2:
				return (clamp(surface_normal.r, 0.0, 1.0) * get_directional_mask_color_ramp_value(clamp(surface_normal.r, 0.0, 1.0)));
			case 3:
				return (abs(clamp(surface_normal.r, -1.0, 0.0)) * get_directional_mask_color_ramp_value(abs(clamp(surface_normal.r, -1.0, 0.0))));
			case 4:
				return (abs(surface_normal.g) * get_directional_mask_color_ramp_value(abs(surface_normal.g)));
			case 5:
				return (clamp(surface_normal.g, 0.0, 1.0) * get_directional_mask_color_ramp_value(clamp(surface_normal.g, 0.0, 1.0)));
			case 6:
				return (abs(clamp(surface_normal.g, -1.0, 0.0)) * get_directional_mask_color_ramp_value(abs(clamp(surface_normal.g, -1.0, 0.0))));
			case 7:
				return (abs(surface_normal.b) * get_directional_mask_color_ramp_value(abs(surface_normal.b)));
			case 8:
				return (clamp(surface_normal.b, 0.0, 1.0) * get_directional_mask_color_ramp_value(clamp(surface_normal.b, 0.0, 1.0)));
			case 9:
				return (abs(clamp(surface_normal.b, -1.0, 0.0)) * get_directional_mask_color_ramp_value(abs(clamp(surface_normal.b, -1.0, 0.0))));
			}
}

float get_positional_mask(vec3 local_v_position, vec3 global_v_position) {
	float positional_mask_value;

	vec3 v_position = (float(positional_mask_mode == 1) * local_v_position) + (float(positional_mask_mode == 2) * global_v_position);

	switch (positional_mask_axis) {
			case 0:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.x + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
			case 1:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.y + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
			case 2:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.z + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
		};

	return get_positional_mask_color_ramp_value(positional_mask_value) * float(positional_mask_mode != 0);
}

float get_vertex_color_mask() {
	switch (vertex_color_mask_mode) {
		case 0:
			return 0.0;
		case 1: //RED
			vec4 color_ramp_color = texture(vertex_color_mask_color_ramp, vec2(clamp(vertex_color.r, 0.005, 0.995), 0.0));
			return mix(vertex_color.r, color_ramp_color.r, color_ramp_color.a);
		case 2: //GREEN
			vec4 color_ramp_color = texture(vertex_color_mask_color_ramp, vec2(clamp(vertex_color.g, 0.005, 0.995), 0.0));
			return mix(vertex_color.g, color_ramp_color.g, color_ramp_color.a);
		case 3: //BLUE
			vec4 color_ramp_color = texture(vertex_color_mask_color_ramp, vec2(clamp(vertex_color.b, 0.005, 0.995), 0.0));
			return mix(vertex_color.b, color_ramp_color.b, color_ramp_color.a);
	}
}

float get_normal_map_slope_mask(vec2 uv) {
	vec4 normal_map_value = texture(normal, uv);
	float mask_value = (abs(normal_map_value.r - 0.5) * float(abs(normal_map_value.r - 0.5) > abs(normal_map_value.g - 0.5)) + abs(normal_map_value.g - 0.5) * float(abs(normal_map_value.r - 0.5) < abs(normal_map_value.g - 0.5))) * float(normal_map_slope_mask_mode != 0);
	return get_normal_map_slope_mask_color_ramp_value(mask_value);
}

float get_uv_mask(vec2 uv) {
	float x_max = UV_mask_X_max;
	float x_min = UV_mask_X_min;
	float x_factor = clamp(1.0/(x_max - x_min) * uv.x + (1.0 - 1.0/(x_max - x_min) * x_max), 0.002, 0.998);
	vec4 color_ramp_color = texture(UV_mask_X_color_ramp, vec2(x_factor, 0));
	float x_value = mix(x_factor, color_ramp_color.r, color_ramp_color.a);

	float y_max = UV_mask_Y_max;
	float y_min = UV_mask_Y_min;
	float y_factor = clamp(1.0/(y_max - y_min) * uv.y + (1.0 - 1.0/(y_max - y_min) * y_max), 0.002, 0.998);
	color_ramp_color = texture(UV_mask_X_color_ramp, vec2(y_factor, 0));
	float y_value = mix(y_factor, color_ramp_color.r, color_ramp_color.a);

	float result;

	switch (UV_mask_XY_mixing_operation) {
		case 0:
			result = y_value + x_value;
		case 1:
			switch (UV_mask_XY_mixing_order) {
				case 0:
					result = x_value - y_value;
				case 1:
					result = y_value - x_value;
			};
		case 2:
			result = y_value * x_value;
	};

	return result * float(UV_mask_enabled);
}

float get_mask_step_mix(int step, vec2 uv1, vec2 uv2, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position) {
	vec2 mask_a_uv = (uv1 * float(texture_mask_A_UV_assignment == 0) + uv2 * float(texture_mask_A_UV_assignment == 1));
	vec2 mask_b_uv = (uv1 * float(texture_mask_B_UV_assignment == 0) + uv2 * float(texture_mask_B_UV_assignment == 1));

	vec2 uv_mask_uv = (uv1 * float(UV_mask_UV_assignment == 0) + uv2 * float(UV_mask_UV_assignment == 1));

	vec2 normal_map_uv = uv1 * float(normal_map_UV_assignment == 0) + uv2 * float(normal_map_UV_assignment == 1);

	return clamp((get_texture_mask(mask_a_uv, mask_b_uv) * float(get_mask_mixing_step(1) == step) + get_directional_mask(local_surface_normal, global_surface_normal) * float(get_mask_mixing_step(2) == step) + get_positional_mask(local_vertex_position, global_vertex_position) * float(get_mask_mixing_step(3) == step) + get_vertex_color_mask() * float(get_mask_mixing_step(4) == step) + get_normal_map_slope_mask(normal_map_uv) * float(get_mask_mixing_step(5) == step) + get_uv_mask(uv_mask_uv) * float(get_mask_mixing_step(6) == step)), 0.0, 1.0);
}

float get_resulting_mask(vec2 uv1, vec2 uv2, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position) {
	float step_1_mix = get_mask_step_mix(1, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);

	float step_2_mix = get_mask_step_mix(2, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_step_mixing_operation(2)) {
		case 0:
			step_2_mix = clamp(step_1_mix + (step_2_mix * float(step_1_mix >= get_step_mixing_threshold(2))), 0.0, 1.0);
			break;
		case 1:
			step_2_mix = clamp(step_1_mix - (step_2_mix * float(step_1_mix >= get_step_mixing_threshold(2))), 0.0, 1.0);
			break;
		case 2:
			if (step_1_mix >= get_step_mixing_threshold(2)) {
				step_2_mix = clamp(step_1_mix * step_2_mix, 0.0, 1.0);
			}
			else {
				step_2_mix = step_1_mix;
				}
			break;
	}

	float step_3_mix = get_mask_step_mix(3, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_step_mixing_operation(3)) {
		case 0:
			step_3_mix = clamp(step_2_mix + (step_3_mix * float(step_2_mix >= get_step_mixing_threshold(3))), 0.0, 1.0);
			break;
		case 1:
			step_3_mix = clamp(step_2_mix - (step_3_mix * float(step_2_mix >= get_step_mixing_threshold(3))), 0.0, 1.0);
			break;
		case 2:
			if (step_2_mix >= get_step_mixing_threshold(3)) {
				step_3_mix = clamp(step_2_mix * step_3_mix, 0.0, 1.0);
			}
			else {
				step_3_mix = step_2_mix;
				}
			break;
	}

	float step_4_mix = get_mask_step_mix(4, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_step_mixing_operation(4)) {
		case 0:
			step_4_mix = clamp(step_3_mix + (step_4_mix * float(step_3_mix >= get_step_mixing_threshold(4))), 0.0, 1.0);
			break;
		case 1:
			step_4_mix = clamp(step_3_mix - (step_4_mix * float(step_3_mix >= get_step_mixing_threshold(4))), 0.0, 1.0);
			break;
		case 2:
			if (step_3_mix >= get_step_mixing_threshold(4)) {
				step_4_mix = clamp(step_3_mix * step_4_mix, 0.0, 1.0);
			}
			else {
				step_4_mix = step_3_mix;
				}
			break;
	}

	float step_5_mix = get_mask_step_mix(5, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_step_mixing_operation(5)) {
		case 0:
			step_5_mix = clamp(step_4_mix + (step_5_mix * float(step_4_mix >= get_step_mixing_threshold(5))), 0.0, 1.0);
			break;
		case 1:
			step_5_mix = clamp(step_4_mix - (step_5_mix * float(step_4_mix >= get_step_mixing_threshold(5))), 0.0, 1.0);
			break;
		case 2:
			if (step_4_mix >= get_step_mixing_threshold(5)) {
				step_5_mix = clamp(step_4_mix * step_5_mix, 0.0, 1.0);
			}
			else {
				step_5_mix = step_4_mix;
				}
			break;
	}

	float step_6_mix = get_mask_step_mix(6, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_step_mixing_operation(6)) {
		case 0:
			step_6_mix = clamp(step_4_mix + (step_6_mix * float(step_5_mix >= get_step_mixing_threshold(6))), 0.0, 1.0);
			break;
		case 1:
			step_6_mix = clamp(step_4_mix - (step_6_mix * float(step_5_mix >= get_step_mixing_threshold(6))), 0.0, 1.0);
			break;
		case 2:
			if (step_5_mix >= get_step_mixing_threshold(6)) {
				step_6_mix = clamp(step_5_mix * step_6_mix, 0.0, 1.0);
			}
			else {
				step_6_mix = step_5_mix;
				}
			break;
	}

	switch (post_effect) {
		case 1:
			step_6_mix = step_6_mix * 0.5;
		case 2:
			step_6_mix = 0.0;
	};

	//return step_3_mix;
	return get_mask_post_color_ramp_value(clamp(step_5_mix, 0.0, 1.0) * mask_amplification + 0.002);
}

void vertex() {
	switch (vertex_displacement_mode) {
		case 1:
			VERTEX.xyz += NORMAL.xyz * vertex_displacement_scale * texture(vertex_displacement_map, UV).r;
			break;
	}
	local_vertex_normal = NORMAL.rgb;
	global_vertex_normal = local_vertex_normal * MODEL_NORMAL_MATRIX;
	local_vertex_pos = VERTEX.xyz;
	global_vertex_pos = (vec4(local_vertex_normal, 1.0) * MODEL_MATRIX).xyz;
}

void fragment() {
	vertex_color = COLOR.rgb;

	if (enabled == true) {
		vec2 uv1 = get_uv(0, UV);
		vec2 uv2 = get_uv(1, UV);

		vec3 albedo_mix = vec3(0.0, 0.0, 0.0);
		float occlusion_mix = 0.0;
		float roughness_mix = 0.0;
		float metallic_mix = 0.0;
		
		int normal_uv_map_index = get_map_uv_index(0);
		int albedo_uv_map_index = get_map_uv_index(1);
		int occlusion_uv_map_index = get_map_uv_index(2);
		int roughness_uv_map_index = get_map_uv_index(3);
		int metallic_uv_map_index = get_map_uv_index(4);

		vec4 albedo_texture = texture(albedo, uv1 * float(albedo_uv_map_index == 0) + uv2 * float(albedo_uv_map_index == 1));
		vec2 occlusion_factor = texture(occlusion_map, uv1 * float(occlusion_uv_map_index == 0) + uv2 * float(occlusion_uv_map_index == 1)).ra * float(orm_mode) + texture(orm_map, uv1 * float(occlusion_uv_map_index == 0) + uv2 * float(occlusion_uv_map_index == 1)).ra * (1.0 - float(orm_mode));
		vec2 roughness_factor = texture(roughness_map, uv1 * float(roughness_uv_map_index == 0) + uv2 * float(roughness_uv_map_index == 1)).ra * float(orm_mode) + texture(orm_map, uv1 * float(roughness_uv_map_index == 0) + uv2 * float(roughness_uv_map_index == 1)).ga * (1.0 - float(orm_mode));
		vec2 metallic_factor = texture(metallic_map, uv1 * float(metallic_uv_map_index == 0) + uv2 * float(metallic_uv_map_index == 1)).ra * float(orm_mode) + texture(orm_map, uv1 * float(metallic_uv_map_index == 0) + uv2 * float(metallic_uv_map_index == 1)).ra * (1.0 - float(orm_mode));
		vec3 normal_map = texture(normal, uv1 * float(normal_uv_map_index == 0) + uv2 * float(normal_uv_map_index == 1)).rgb;
		
		vec3 normal_mix = normal_map;
		
		int mask_A_uv_map_index = get_map_uv_index(5);
		int mask_B_uv_map_index = get_map_uv_index(6);

		float mask_factor = get_resulting_mask(uv1, uv2, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos);
		albedo_mix = mix(albedo_mix, albedo_texture.rgb, mask_factor * albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(mask_factor), float(consolidate_masks));

		occlusion_mix = mix(occlusion_mix, occlusion_factor.x, mask_factor * occlusion_factor.y);
		roughness_mix = mix(roughness_mix, roughness_factor.x, mask_factor * roughness_factor.y);
		metallic_mix = mix(metallic_mix, metallic_factor.x, mask_factor * metallic_factor.y);
		normal_mix = mix(normal_mix, normal_map, mask_factor * (1.0 - float(propagate_normals)));
	
		ALBEDO = albedo_mix.rgb;
		//ALBEDO = vec3(get_positional_mask_for_layer(1, local_vertex_pos, global_vertex_pos));
		//ALBEDO = vec3(get_directional_mask_for_layer(1, local_vertex_normal, global_vertex_normal));
		//ALBEDO = vec3(get_resulting_mask_for_layer(1, UV, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos));
		//ALBEDO = vec3(get_vertex_color_mask_for_layer(1));
		ROUGHNESS = roughness_mix;
		METALLIC = metallic_mix;
//
		NORMAL_MAP = normal_mix;
		
		ALPHA = mask_factor;
	}
	else {
		ALPHA = 0.0;
	}

}