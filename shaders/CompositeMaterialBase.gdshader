shader_type spatial;

//This shader is a "lite" version of CompositeMaterial, (although not necessarily faster), and simultaneously the base for the
//automatically generated shader code. Throughout the file you will find tags which indicate certain
//regions of code that can be used by a script to generate another script which can then dynamically 
//generate CompositeMaterial shaders. This shader is also able to run on its own.

//Todo: vertex displacement normal recalculation, uv rotation by uv offset map r channel

render_mode cull_disabled, depth_prepass_alpha;

//indeces/enums:
//
//	maps/textures:
// 		0:normal
// 		1:albedo
// 		2:occlusion
// 		3:roughness
//		4:metallic
//		5:texture mask A
//		6:texture mask B
//      7:UV Mask

//pre_base_string
uniform int albedo_channel = 0;

group_uniforms vertex_displacement;
uniform int vertex_displacement_mode : hint_enum("Disabled", "Normal") = 0;
uniform float vertex_displacement_scale = -1.0;
uniform sampler2D vertex_displacement_map : hint_default_black;
//end pre_base_string

group_uniforms layer_C;
/**
 * Whether this layer will display at all.
 */
uniform bool layer_C_enabled = true;
/**
 * In what place this layer will show. Layer 1 is the bottom layer, layer 3 the top layer. Do not set this to the same value on multiple layers.
 */
//ignore
uniform int layer_C_processing_index : hint_enum("Bottom", "Middle", "Top") = 2;
//end ignore
uniform lowp float layer_C_lod_level = 0.0;

uniform sampler2D layer_C_albedo : source_color, hint_default_transparent;

uniform sampler2D layer_C_normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool layer_C_propagate_normals = false;

group_uniforms layer_C.uv1;

uniform int layer_C_uv1_mode : hint_enum("From Mesh", "Triplanar");
uniform int layer_C_uv1_triplanar_mode : hint_enum("Local", "Global");

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_C_uv1_scale = vec2(1.0);
uniform vec2 layer_C_uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_C_uv1_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_C_uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform lowp float layer_C_uv1_offset_map_factor = 1.0;

group_uniforms layer_C.uv2;

uniform int layer_C_uv2_mode : hint_enum("From Mesh", "Triplanar");
uniform int layer_C_uv2_triplanar_mode : hint_enum("Local", "Global");

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_C_uv2_scale = vec2(1.0);
uniform vec2 layer_C_uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_C_uv2_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_C_uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_C_uv2_offset_map_factor = 1.0;

group_uniforms layer_C.uv_map_assignment;
uniform int layer_C_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_C_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_C_UV_mask_UV_assignment : hint_enum("UV1", "UV2") = 0;

group_uniforms layer_C.ORM;
uniform int layer_C_orm_mode : hint_enum("Single map", "Seperate maps", "Values") = 0;
uniform sampler2D layer_C_orm_map : hint_default_transparent;
uniform sampler2D layer_C_occlusion_map : hint_default_transparent;
uniform sampler2D layer_C_roughness_map : hint_default_transparent;
uniform sampler2D layer_C_metallic_map : hint_default_transparent;
uniform lowp float layer_C_occlusion_value : hint_range(0.0, 1.0, 0.001) = 0.5;
uniform lowp float layer_C_roughness_value : hint_range(0.0, 1.0, 0.001) = 0.5;
uniform lowp float layer_C_metallic_value : hint_range(0.0, 1.0, 0.001) = 0.5;
/**
 * Whether this layer should use the same ORM texture as the underlying layer.
 */
group_uniforms layer_C.masking;
/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool layer_C_consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask will be multiplied.
 */
uniform float layer_C_mask_amplification : hint_range(0.0, 10.0) = 1.0;

/**
 * By what type of operation step 1 and step 2 will be mixed.
 */
uniform int layer_C_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * From which mask value on the masks assigned to step 1, step 1 and step 2 will mix.
 */
uniform float layer_C_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D layer_C_post_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_C_post_effect : hint_enum("None", "Drip", "Expand-Blur") = 0;
uniform float layer_C_post_effect_parameter_1 : hint_range(0.0, 1.0) = 0.1;
uniform float layer_C_post_effect_parameter_2 = 0.0;
uniform float layer_C_post_effect_parameter_3 = 0.0;

group_uniforms layer_C.texture_masks;
uniform bool layer_C_texture_mask_A_enabled = true;
uniform sampler2D layer_C_texture_mask_A : hint_default_transparent;
uniform sampler2D layer_C_texture_mask_A_color_ramp : hint_default_transparent, repeat_disable;
uniform bool layer_C_texture_mask_B_enabled = false;
uniform sampler2D layer_C_texture_mask_B : hint_default_transparent;
uniform sampler2D layer_C_texture_mask_B_color_ramp : hint_default_transparent, repeat_disable;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int layer_C_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int layer_C_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int layer_C_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 1;

group_uniforms layer_C.directional_mask;
/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int layer_C_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int layer_C_directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D layer_C_directional_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_C_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 2;

group_uniforms layer_C.positional_mask;
uniform int layer_C_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D layer_C_positional_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_C_positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_C_positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_C_positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int layer_C_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 3;

group_uniforms layer_C.vertex_color_mask;
/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int layer_C_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D layer_C_vertex_color_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_C_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 4;

group_uniforms layer_C.UV_mask;
uniform int layer_C_UV_mask_mode : hint_enum("Disabled", "Tile", "Clamp") = 0;

group_uniforms layer_C.normal_map_slope_mask;

uniform int layer_C_normal_map_slope_mask_mode : hint_enum("Disabled", "Pre-Mask", "Post-Mask") = 0;
uniform int layer_C_normal_map_slope_mask_source : hint_enum("Previous Layer", "Current Layer") = 0;
uniform sampler2D layer_C_normal_map_slope_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_C_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5;

group_uniforms layer_C.UV_mask;

uniform bool layer_C_UV_mask_enabled = false;
uniform int layer_C_UV_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 6;
uniform float layer_C_UV_mask_X_min = 0.0;
uniform float layer_C_UV_mask_X_max = 1.0;
uniform sampler2D layer_C_UV_mask_X_color_ramp : hint_default_transparent, repeat_disable;
uniform float layer_C_UV_mask_Y_min = 0.0;
uniform float layer_C_UV_mask_Y_max = 1.0;
uniform sampler2D layer_C_UV_mask_Y_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_C_UV_mask_XY_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform int layer_C_UV_mask_XY_mixing_order : hint_enum("X-Y", "Y-X") = 0;

//==========================================================================


//==========================================================================

group_uniforms layer_B;
/**
 * Whether this layer will display at all.
 */
uniform bool layer_B_enabled = true;
/**
 * In what place this layer will show. Layer 1 is the bottom layer, layer 3 the top layer. Do not set this to the same value on multiple layers.
 */
//ignore
uniform int layer_B_processing_index : hint_enum("Bottom", "Middle", "Top") = 1;
//end ignore
uniform lowp float layer_B_lod_level = 0.0;

uniform sampler2D layer_B_albedo : source_color, hint_default_transparent;

uniform sampler2D layer_B_normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool layer_B_propagate_normals = false;

group_uniforms layer_B.uv1;

uniform int layer_B_uv1_mode : hint_enum("From Mesh", "Triplanar");
uniform int layer_B_uv1_triplanar_mode : hint_enum("Local", "Global");

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_B_uv1_scale = vec2(1.0);
uniform vec2 layer_B_uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_B_uv1_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_B_uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_B_uv1_offset_map_factor = 1.0;

group_uniforms layer_B.uv2;

uniform int layer_B_uv2_mode : hint_enum("From Mesh", "Triplanar");
uniform int layer_B_uv2_triplanar_mode : hint_enum("Local", "Global");

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_B_uv2_scale = vec2(1.0);
uniform vec2 layer_B_uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_B_uv2_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_B_uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_B_uv2_offset_map_factor = 1.0;

group_uniforms layer_B.uv_map_assignment;
uniform int layer_B_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_B_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_B_UV_mask_UV_assignment : hint_enum("UV1", "UV2") = 0;

group_uniforms layer_B.ORM;
uniform int layer_B_orm_mode : hint_enum("Single map", "Seperate maps", "Values") = 0;
uniform sampler2D layer_B_orm_map : hint_default_transparent;
uniform sampler2D layer_B_occlusion_map : hint_default_transparent;
uniform sampler2D layer_B_roughness_map : hint_default_transparent;
uniform sampler2D layer_B_metallic_map : hint_default_transparent;
uniform lowp float layer_B_occlusion_value : hint_range(0.0, 1.0, 0.001) = 0.5;
uniform lowp float layer_B_roughness_value : hint_range(0.0, 1.0, 0.001) = 0.5;
uniform lowp float layer_B_metallic_value : hint_range(0.0, 1.0, 0.001) = 0.5;
/**
 * Whether this layer should use the same ORM texture as the underlying layer.
 */
group_uniforms layer_B.masking;
/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool layer_B_consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask (A, B and Directional) will be multiplied.
 */
uniform float layer_B_mask_amplification : hint_range(0.0, 10.0) = 1.0;

uniform int layer_B_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D layer_B_post_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_B_post_effect : hint_enum("None", "Drip", "Expand-Blur") = 0;
uniform float layer_B_post_effect_parameter_1 : hint_range(0.0, 1.0) = 0.1;
uniform float layer_B_post_effect_parameter_2 = 0.0;
uniform float layer_B_post_effect_parameter_3 = 0.0;

group_uniforms layer_B.texture_masks;
uniform bool layer_B_texture_mask_A_enabled = true;
uniform sampler2D layer_B_texture_mask_A : hint_default_transparent;
uniform sampler2D layer_B_texture_mask_A_color_ramp : hint_default_transparent, repeat_disable;
uniform bool layer_B_texture_mask_B_enabled = false;
uniform sampler2D layer_B_texture_mask_B : hint_default_transparent;
uniform sampler2D layer_B_texture_mask_B_color_ramp : hint_default_transparent, repeat_disable;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int layer_B_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int layer_B_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int layer_B_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 1;

group_uniforms layer_B.directional_mask;
/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int layer_B_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int layer_B_directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D layer_B_directional_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_B_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 2;

group_uniforms layer_B.positional_mask;
uniform int layer_B_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D layer_B_positional_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_B_positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_B_positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_B_positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int layer_B_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 3;


group_uniforms layer_B.vertex_color_mask;
/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int layer_B_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D layer_B_vertex_color_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_B_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 4;

group_uniforms layer_B.normal_map_slope_mask;

uniform int layer_B_normal_map_slope_mask_mode : hint_enum("Disabled", "Pre-Mask", "Post-Mask") = 0;
uniform int layer_B_normal_map_slope_mask_source : hint_enum("Previous Layer", "Current Layer") = 0;
uniform sampler2D layer_B_normal_map_slope_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_B_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 5;

group_uniforms layer_B.UV_mask;

uniform bool layer_B_UV_mask_enabled = false;
uniform int layer_B_UV_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 6;
uniform float layer_B_UV_mask_X_min = 0.0;
uniform float layer_B_UV_mask_X_max = 1.0;
uniform sampler2D layer_B_UV_mask_X_color_ramp : hint_default_transparent, repeat_disable;
uniform float layer_B_UV_mask_Y_min = 0.0;
uniform float layer_B_UV_mask_Y_max = 1.0;
uniform sampler2D layer_B_UV_mask_Y_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_B_UV_mask_XY_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform int layer_B_UV_mask_XY_mixing_order : hint_enum("X-Y", "Y-X") = 0;

//==========================================================================


//==========================================================================



//parameters_string



group_uniforms layer_A;
/**
 * Whether this layer will display at all.
 */
uniform bool layer_A_enabled = true;
/**
 * In what place this layer will show. Layer 1 is the bottom layer, layer 3 the top layer. Do not set this to the same value on multiple layers.
 */
//ignore
uniform int layer_A_processing_index : hint_enum("Bottom", "Middle", "Top") = 0;
//end ignore
uniform lowp float layer_A_lod_level = 0;

uniform sampler2D layer_A_albedo : source_color, hint_default_transparent;

uniform sampler2D layer_A_normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool layer_A_propagate_normals = false;

group_uniforms layer_A.uv1;

uniform int layer_A_uv1_mode : hint_enum("From Mesh", "Triplanar");
uniform int layer_A_uv1_triplanar_mode : hint_enum("Local", "Global");

/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_A_uv1_scale = vec2(1.0);
uniform vec2 layer_A_uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_A_uv1_offset_map : hint_default_transparent;
uniform vec2 layer_A_uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_A_uv1_offset_map_factor = 1.0;

group_uniforms layer_A.uv2;

uniform int layer_A_uv2_mode : hint_enum("From Mesh", "Triplanar");
uniform int layer_A_uv2_triplanar_mode : hint_enum("Local", "Global");
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_A_uv2_scale = vec2(1.0);
uniform vec2 layer_A_uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_A_uv2_offset_map : hint_default_transparent;
uniform vec2 layer_A_uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_A_uv2_offset_map_factor = 1.0;

group_uniforms layer_A.uv_map_assignment;
uniform int layer_A_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_A_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_A_UV_mask_UV_assignment : hint_enum("UV1", "UV2") = 0;

group_uniforms layer_A.ORM;
uniform int layer_A_orm_mode : hint_enum("Single map", "Seperate maps", "Values") = 0;
uniform sampler2D layer_A_orm_map : hint_default_transparent;
uniform sampler2D layer_A_occlusion_map : hint_default_transparent;
uniform sampler2D layer_A_roughness_map : hint_default_transparent;
uniform sampler2D layer_A_metallic_map : hint_default_transparent;
uniform lowp float layer_A_occlusion_value : hint_range(0.0, 1.0, 0.001) = 0.5;
uniform lowp float layer_A_roughness_value : hint_range(0.0, 1.0, 0.001) = 0.5;
uniform lowp float layer_A_metallic_value : hint_range(0.0, 1.0, 0.001) = 0.5;
/**
 * Whether this layer should use the same ORM texture as the underlying layer.
 */
group_uniforms layer_A.masking;
/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool layer_A_consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask (A, B and Directional) will be multiplied.
 */
uniform float layer_A_mask_amplification : hint_range(0.0, 10.0) = 1.0;

uniform int layer_A_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D layer_A_post_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_A_post_effect : hint_enum("None", "Drip", "Expand-Blur") = 0;
uniform float layer_A_post_effect_parameter_1 : hint_range(0.0, 1.0) = 0.1;
uniform float layer_A_post_effect_parameter_2 = 0.0;
uniform float layer_A_post_effect_parameter_3 = 0.0;

group_uniforms layer_A.texture_masks;
uniform bool layer_A_texture_mask_A_enabled = true;
uniform sampler2D layer_A_texture_mask_A : hint_default_transparent;
uniform sampler2D layer_A_texture_mask_A_color_ramp : hint_default_transparent, repeat_disable;
uniform bool layer_A_texture_mask_B_enabled = false;
uniform sampler2D layer_A_texture_mask_B : hint_default_transparent;
uniform sampler2D layer_A_texture_mask_B_color_ramp : hint_default_transparent, repeat_disable;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int layer_A_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int layer_A_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int layer_A_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 1;

group_uniforms layer_A.directional_mask;
/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int layer_A_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int layer_A_directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D layer_A_directional_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_A_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 2;

group_uniforms layer_A.positional_mask;
uniform int layer_A_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D layer_A_positional_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_A_positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_A_positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_A_positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int layer_A_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 3;


group_uniforms layer_A.vertex_color_mask;
/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int layer_A_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D layer_A_vertex_color_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_A_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 4;

group_uniforms layer_A.normal_map_slope_mask;

uniform int layer_A_normal_map_slope_mask_mode : hint_enum("Disabled", "Pre-Mask", "Post-Mask") = 0;
uniform int layer_A_normal_map_slope_mask_source : hint_enum("Previous Layer", "Current Layer") = 0;
uniform sampler2D layer_A_normal_map_slope_mask_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_A_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5;

group_uniforms layer_A.UV_mask;

uniform bool layer_A_UV_mask_enabled = false;
uniform int layer_A_UV_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5", "Step 6:6") = 6;
uniform float layer_A_UV_mask_X_min = 0.0;
uniform float layer_A_UV_mask_X_max = 1.0;
uniform sampler2D layer_A_UV_mask_X_color_ramp : hint_default_transparent, repeat_disable;
uniform float layer_A_UV_mask_Y_min = 0.0;
uniform float layer_A_UV_mask_Y_max = 1.0;
uniform sampler2D layer_A_UV_mask_Y_color_ramp : hint_default_transparent, repeat_disable;
uniform int layer_A_UV_mask_XY_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform int layer_A_UV_mask_XY_mixing_order : hint_enum("X-Y", "Y-X") = 0;

//end parameters_string

group_uniforms layer_base;

uniform bool layer_base_enabled = true;

uniform vec2 layer_base_uv_scale = vec2(1.0, 1.0);
uniform vec2 layer_base_uv_offset = vec2(0.0, 0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_base_uv_offset_map : hint_default_transparent, filter_nearest;
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_base_uv_offset_map_scale = 1.0;
uniform sampler2D layer_base_albedo : source_color, hint_default_transparent;
uniform sampler2D layer_base_normal : hint_normal;
uniform sampler2D layer_base_occlusion_map : hint_default_black;
uniform sampler2D layer_base_roughness_map : hint_default_black;
uniform sampler2D layer_base_metallic_map : hint_default_black;

//base_string

varying vec3 local_vertex_normal;
varying vec3 global_vertex_normal;
varying vec3 global_vertex_pos;
varying vec3 local_vertex_pos;
varying vec3 vertex_color;
varying vec3 global_camera_pos;

//==========================================================================


//==========================================================================


// VVV     prevents these functions from getting interpreted as anything else
//include
float get_fragment_distance_to_camera() {
	return distance(global_vertex_pos, global_camera_pos);
}

float get_mip_modifier() {
	float x = get_fragment_distance_to_camera();
	return (3.0 / (1.0 + pow(10.0, -(x - 8.0)))) + sqrt(x) - 3.0;
}
//end include





//ignore
int get_processing_layer_assigned_layer(int layer_processing_index) {
	if (layer_A_processing_index == layer_processing_index) {
		return 1;
	}
	else if (layer_B_processing_index == layer_processing_index) {
		return 2;
	}
	else if (layer_C_processing_index == layer_processing_index) {
		return 3;
	}
}
//end ignore

bool get_layer_enabled(int layer) {
	
	return (layer_A_enabled && layer == 1) || (layer_B_enabled && layer == 2) || (layer_C_enabled && layer == 3);
	
	//switch (layer) {
		//case 1:
			//return layer_A_enabled;
		//case 2:
			//return layer_B_enabled;
		//case 3:
			//return layer_C_enabled;
	//}
}

int get_layer_uv_mode(int layer, int uv_map_index) {
	
	return ((layer_A_uv1_mode * int(uv_map_index == 0) + layer_A_uv2_mode * int(uv_map_index == 1)) * int(layer == 1)) + ((layer_B_uv1_mode * int(uv_map_index == 0) + layer_B_uv2_mode * int(uv_map_index == 1)) * int(layer == 2)) + ((layer_C_uv1_mode * int(uv_map_index == 0) + layer_C_uv2_mode * int(uv_map_index == 1)) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_uv1_mode * int(uv_map_index == 0) + layer_A_uv2_mode * int(uv_map_index == 1);
		//case 2:
			//return layer_A_uv1_mode * int(uv_map_index == 0) + layer_A_uv2_mode * int(uv_map_index == 1);
		//case 3:
			//return layer_A_uv1_mode * int(uv_map_index == 0) + layer_A_uv2_mode * int(uv_map_index == 1);
	//}
}

vec2 get_layer_uv_offset(int layer, int uv_map_index, vec2 uv) {
	switch (layer) {
		case 1: 
			{
			vec4 color;
			if (uv_map_index == 0) {
				color = texture(layer_A_uv1_offset_map, uv * layer_A_uv1_offset_map_scale) * layer_A_uv1_offset_map_factor;
			}
			else {
				color = texture(layer_A_uv2_offset_map, uv * layer_A_uv2_offset_map_scale) * layer_A_uv2_offset_map_factor;
			}
			return color.rg * color.a;
		}
		case 2:
			vec4 color;
			if (uv_map_index == 0) {
				color = texture(layer_B_uv1_offset_map, uv * layer_B_uv1_offset_map_scale) * layer_B_uv1_offset_map_factor;
			}
			else {
				color = texture(layer_B_uv2_offset_map, uv * layer_B_uv2_offset_map_scale) * layer_B_uv2_offset_map_factor;
			}
			return color.rg * color.a;
		case 3:
			vec4 color;
			if (uv_map_index == 0) {
				color = texture(layer_C_uv1_offset_map, uv * layer_C_uv1_offset_map_scale) * layer_C_uv1_offset_map_factor;
			}
			else {
				color = texture(layer_C_uv2_offset_map, uv * layer_C_uv2_offset_map_scale) * layer_C_uv2_offset_map_factor;
			}
			return color.rg * color.a;
			}
	//end ignore_sc
}

vec2 get_layer_uv_scale(int layer, int uv_map_index) {
	
	return ((layer_A_uv1_scale * float(uv_map_index == 0) + layer_A_uv2_scale * float(uv_map_index == 1)) * float(layer == 1)) + ((layer_B_uv1_scale * float(uv_map_index == 0) + layer_B_uv2_scale * float(uv_map_index == 1)) * float(layer == 2)) + ((layer_C_uv1_scale * float(uv_map_index == 0) + layer_C_uv2_scale * float(uv_map_index == 1)) * float(layer == 2));
	
	//switch (layer) {
		//case 1:
			//return layer_A_uv1_scale * float(uv_map_index == 0) + layer_A_uv2_scale * float(uv_map_index == 1);
		//case 2:
			//return layer_B_uv1_scale * float(uv_map_index == 0) + layer_B_uv2_scale * float(uv_map_index == 1);
		//case 3:
			//return layer_C_uv1_scale * float(uv_map_index == 0) + layer_C_uv2_scale * float(uv_map_index == 1);
	//}
}

vec2 get_layer_uv(int layer, int uv_map_index, vec2 uv) {
	
	return (((uv + get_layer_uv_offset(1, uv_map_index, uv)) * layer_A_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(1, 1, uv) + layer_A_uv2_offset) * layer_A_uv2_scale * float(uv_map_index == 1)) * float(layer == 1)) + (((uv + get_layer_uv_offset(2, uv_map_index, uv)) * layer_B_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(2, 1, uv) + layer_B_uv2_offset) * layer_B_uv2_scale * float(uv_map_index == 1)) * float(layer == 2)) + (((uv + get_layer_uv_offset(3, uv_map_index, uv)) * layer_C_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(3, 1, uv) + layer_C_uv2_offset) * layer_C_uv2_scale * float(uv_map_index == 1)) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return (uv + get_layer_uv_offset(1, uv_map_index, uv)) * layer_A_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(1, 1, uv) + layer_A_uv2_offset) * layer_A_uv2_scale * float(uv_map_index == 1);
		//case 2:
			//return (uv + get_layer_uv_offset(2, uv_map_index, uv)) * layer_B_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(2, 1, uv) + layer_B_uv2_offset) * layer_B_uv2_scale * float(uv_map_index == 1);
		//case 3:
			//return (uv + get_layer_uv_offset(3, uv_map_index, uv)) * layer_C_uv1_scale * float(uv_map_index == 0) + (uv + get_layer_uv_offset(3, 1, uv) + layer_C_uv2_offset) * layer_C_uv2_scale * float(uv_map_index == 1);
	//}
}

vec2 get_layer_triplanar_uv(int layer, int uv_map_index, vec3 pos, vec3 normal, vec2 uv) {

	normal = abs(normal);

	int direction = 0;
	//0=x, 1=y, 2=z
	float largest_comp = 0.0;

	if (normal.x > largest_comp) {
		direction = 0;
		largest_comp = normal.x;
	}
	if (normal.y > largest_comp) {
		direction = 1;
		largest_comp = normal.y;
	}
	if (normal.z > largest_comp) {
		direction = 2;
	}

	vec2 uv_offset = get_layer_uv_offset(layer, uv_map_index, uv);
	vec2 uv_scale = get_layer_uv_scale(layer, uv_map_index);

	vec2 raw_uv = vec2(pos.z, pos.y) * float(direction == 0) + vec2(pos.x, pos.z) * float(direction == 1) + vec2(pos.x, pos.y) * float(direction == 2);

	//if (direction == 0) {
		//raw_uv = vec2(pos.z, pos.y);
	//}
	//else if (direction == 1) {
		//raw_uv = vec2(pos.x, pos.z);
	//}
	//else if (direction == 2) {
		//raw_uv = vec2(pos.x, pos.y);
	//}

	return (vec2(raw_uv) + uv_offset) * uv_scale;
}

int get_layer_uv_triplanar_mode(int layer, int uv_map_index) {
	
	return ((layer_A_uv1_triplanar_mode * int(uv_map_index == 0) + layer_A_uv2_triplanar_mode * int(uv_map_index == 1)) * int(layer == 1)) + ((layer_B_uv1_triplanar_mode * int(uv_map_index == 0) + layer_B_uv2_triplanar_mode * int(uv_map_index == 1)) * int(layer == 2)) + ((layer_C_uv1_triplanar_mode * int(uv_map_index == 0) + layer_C_uv2_triplanar_mode * int(uv_map_index == 1)) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_uv1_triplanar_mode * int(uv_map_index == 0) + layer_A_uv2_triplanar_mode * int(uv_map_index == 1);
		//case 2:
			//return layer_B_uv1_triplanar_mode * int(uv_map_index == 0) + layer_B_uv2_triplanar_mode * int(uv_map_index == 1);
		//case 3:
			//return layer_C_uv1_triplanar_mode * int(uv_map_index == 0) + layer_C_uv2_triplanar_mode * int(uv_map_index == 1);
	//}
}

int get_layer_map_uv_index(int layer, int map_index) {
	
	return ((layer_A_normal_map_UV_assignment * int(map_index == 0) + layer_A_albedo_map_UV_assignment * int(map_index == 1) + layer_A_occlusion_map_UV_assignment * int(map_index == 2) + layer_A_roughness_map_UV_assignment * int(map_index == 3) + layer_A_metallic_map_UV_assignment * int(map_index == 4) + layer_A_UV_offset_map_UV_assignment * int(map_index == 5) + layer_A_texture_mask_A_UV_assignment * int(map_index == 6) + layer_A_texture_mask_B_UV_assignment * int(map_index == 7) + layer_A_UV_mask_UV_assignment * int(map_index == 8)) * int(layer == 1)) + ((layer_B_normal_map_UV_assignment * int(map_index == 0) + layer_B_albedo_map_UV_assignment * int(map_index == 1) + layer_B_occlusion_map_UV_assignment * int(map_index == 2) + layer_B_roughness_map_UV_assignment * int(map_index == 3) + layer_B_metallic_map_UV_assignment * int(map_index == 4) + layer_B_UV_offset_map_UV_assignment * int(map_index == 5) + layer_B_texture_mask_A_UV_assignment * int(map_index == 6) + layer_B_texture_mask_B_UV_assignment * int(map_index == 7) + layer_B_UV_mask_UV_assignment * int(map_index == 8)) * int(layer == 2)) + ((layer_C_normal_map_UV_assignment * int(map_index == 0) + layer_C_albedo_map_UV_assignment * int(map_index == 1) + layer_C_occlusion_map_UV_assignment * int(map_index == 2) + layer_C_roughness_map_UV_assignment * int(map_index == 3) + layer_C_metallic_map_UV_assignment * int(map_index == 4) + layer_C_UV_offset_map_UV_assignment * int(map_index == 5) + layer_C_texture_mask_A_UV_assignment * int(map_index == 6) + layer_C_texture_mask_B_UV_assignment * int(map_index == 7) + layer_C_UV_mask_UV_assignment * int(map_index == 8)) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_normal_map_UV_assignment * int(map_index == 0) + layer_A_albedo_map_UV_assignment * int(map_index == 1) + layer_A_occlusion_map_UV_assignment * int(map_index == 2) + layer_A_roughness_map_UV_assignment * int(map_index == 3) + layer_A_metallic_map_UV_assignment * int(map_index == 4) + layer_A_UV_offset_map_UV_assignment * int(map_index == 5) + layer_A_texture_mask_A_UV_assignment * int(map_index == 6) + layer_A_texture_mask_B_UV_assignment * int(map_index == 7) + layer_A_UV_mask_UV_assignment * int(map_index == 8);
		//case 2:
			//return layer_B_normal_map_UV_assignment * int(map_index == 0) + layer_B_albedo_map_UV_assignment * int(map_index == 1) + layer_B_occlusion_map_UV_assignment * int(map_index == 2) + layer_B_roughness_map_UV_assignment * int(map_index == 3) + layer_B_metallic_map_UV_assignment * int(map_index == 4) + layer_B_UV_offset_map_UV_assignment * int(map_index == 5) + layer_B_texture_mask_A_UV_assignment * int(map_index == 6) + layer_B_texture_mask_B_UV_assignment * int(map_index == 7) + layer_B_UV_mask_UV_assignment * int(map_index == 8);
		//case 3:
			//return layer_C_normal_map_UV_assignment * int(map_index == 0) + layer_C_albedo_map_UV_assignment * int(map_index == 1) + layer_C_occlusion_map_UV_assignment * int(map_index == 2) + layer_C_roughness_map_UV_assignment * int(map_index == 3) + layer_C_metallic_map_UV_assignment * int(map_index == 4) + layer_C_UV_offset_map_UV_assignment * int(map_index == 5) + layer_C_texture_mask_A_UV_assignment * int(map_index == 6) + layer_C_texture_mask_B_UV_assignment * int(map_index == 7) + layer_C_UV_mask_UV_assignment * int(map_index == 8);
	//}
}

int get_layer_mask_mixing_step(int layer, int mask) {
	
	return ((layer_A_texture_masks_mixing_step * int(mask == 1) + layer_A_directional_mask_mixing_step * int(mask == 2) + layer_A_positional_mask_mixing_step * int(mask == 3) + layer_A_vertex_color_mask_mixing_step * int(mask == 4) + layer_A_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_A_UV_mask_mixing_step * int(mask == 6)) * int(layer == 1)) + ((layer_B_texture_masks_mixing_step * int(mask == 1) + layer_B_directional_mask_mixing_step * int(mask == 2) + layer_B_positional_mask_mixing_step * int(mask == 3) + layer_B_vertex_color_mask_mixing_step * int(mask == 4) + layer_B_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_B_UV_mask_mixing_step * int(mask == 6)) * int(layer == 2)) + ((layer_C_texture_masks_mixing_step * int(mask == 1) + layer_C_directional_mask_mixing_step * int(mask == 2) + layer_C_positional_mask_mixing_step * int(mask == 3) + layer_C_vertex_color_mask_mixing_step * int(mask == 4) + layer_C_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_C_UV_mask_mixing_step * int(mask == 6)) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_texture_masks_mixing_step * int(mask == 1) + layer_A_directional_mask_mixing_step * int(mask == 2) + layer_A_positional_mask_mixing_step * int(mask == 3) + layer_A_vertex_color_mask_mixing_step * int(mask == 4) + layer_A_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_A_UV_mask_mixing_step * int(mask == 6);
		//case 2:
			//return layer_B_texture_masks_mixing_step * int(mask == 1) + layer_B_directional_mask_mixing_step * int(mask == 2) + layer_B_positional_mask_mixing_step * int(mask == 3) + layer_B_vertex_color_mask_mixing_step * int(mask == 4) + layer_B_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_B_UV_mask_mixing_step * int(mask == 6);
		//case 3:
			//return layer_C_texture_masks_mixing_step * int(mask == 1) + layer_C_directional_mask_mixing_step * int(mask == 2) + layer_C_positional_mask_mixing_step * int(mask == 3) + layer_C_vertex_color_mask_mixing_step * int(mask == 4) + layer_C_normal_map_slope_mask_mixing_step * int(mask == 5) + layer_C_UV_mask_mixing_step * int(mask == 6);
	//}
}

int get_layer_mixing_step_mask(int layer, int _step) {
	
	return ((layer_A_texture_masks_mixing_step * int(_step == 1) + layer_A_directional_mask_mixing_step * int(_step == 2) + layer_A_positional_mask_mixing_step * int(_step == 3) + layer_A_vertex_color_mask_mixing_step * int(_step == 4) + layer_A_normal_map_slope_mask_mixing_step * int(_step == 5) + layer_A_UV_mask_mixing_step * int(_step == 6)) * int(layer == 1)) + ((layer_B_texture_masks_mixing_step * int(_step == 1) + layer_B_directional_mask_mixing_step * int(_step == 2) + layer_B_positional_mask_mixing_step * int(_step == 3) + layer_B_vertex_color_mask_mixing_step * int(_step == 4) + layer_B_normal_map_slope_mask_mixing_step * int(_step == 5) + layer_B_UV_mask_mixing_step * int(_step == 6)) * int(layer == 2)) + ((layer_C_texture_masks_mixing_step * int(_step == 1) + layer_C_directional_mask_mixing_step * int(_step == 2) + layer_C_positional_mask_mixing_step * int(_step == 3) + layer_C_vertex_color_mask_mixing_step * int(_step == 4) + layer_C_normal_map_slope_mask_mixing_step * int(_step == 5) + layer_C_UV_mask_mixing_step * int(_step == 6)) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_texture_masks_mixing_step * int(_step == 1) + layer_A_directional_mask_mixing_step * int(_step == 2) + layer_A_positional_mask_mixing_step * int(_step == 3) + layer_A_vertex_color_mask_mixing_step * int(_step == 4) + layer_A_normal_map_slope_mask_mixing_step * int(_step == 5) + layer_A_UV_mask_mixing_step * int(_step == 6);
		//case 2:
			//return layer_B_texture_masks_mixing_step * int(_step == 1) + layer_B_directional_mask_mixing_step * int(_step == 2) + layer_B_positional_mask_mixing_step * int(_step == 3) + layer_B_vertex_color_mask_mixing_step * int(_step == 4) + layer_B_normal_map_slope_mask_mixing_step * int(_step == 5) + layer_B_UV_mask_mixing_step * int(_step == 6);
		//case 3:
			//return layer_C_texture_masks_mixing_step * int(_step == 1) + layer_C_directional_mask_mixing_step * int(_step == 2) + layer_C_positional_mask_mixing_step * int(_step == 3) + layer_C_vertex_color_mask_mixing_step * int(_step == 4) + layer_C_normal_map_slope_mask_mixing_step * int(_step == 5) + layer_C_UV_mask_mixing_step * int(_step == 6);
	//}
}

int get_layer_step_mixing_operation(int layer, int step) {
	
	return (((layer_A_step_2_mixing_operation * int(step == 2) + layer_A_step_3_mixing_operation * int(step == 3) + layer_A_step_4_mixing_operation * int(step == 4) + layer_A_step_5_mixing_operation * int(step == 5))) * int(layer == 1)) + (((layer_B_step_2_mixing_operation * int(step == 2) + layer_B_step_3_mixing_operation * int(step == 3) + layer_B_step_4_mixing_operation * int(step == 4) + layer_B_step_5_mixing_operation * int(step == 5))) * int(layer == 2)) + (((layer_C_step_2_mixing_operation * int(step == 2) + layer_C_step_3_mixing_operation * int(step == 3) + layer_C_step_4_mixing_operation * int(step == 4) + layer_C_step_5_mixing_operation * int(step == 5))) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return (layer_A_step_2_mixing_operation * int(step == 2) + layer_A_step_3_mixing_operation * int(step == 3) + layer_A_step_4_mixing_operation * int(step == 4) + layer_A_step_5_mixing_operation * int(step == 5));
		//case 2:
			//return (layer_B_step_2_mixing_operation * int(step == 2) + layer_B_step_3_mixing_operation * int(step == 3) + layer_B_step_4_mixing_operation * int(step == 4) + layer_B_step_5_mixing_operation * int(step == 5));
		//case 3:
			//return (layer_C_step_2_mixing_operation * int(step == 2) + layer_C_step_3_mixing_operation * int(step == 3) + layer_C_step_4_mixing_operation * int(step == 4) + layer_C_step_5_mixing_operation * int(step == 5));
	//}
}

float get_layer_step_mixing_threshold(int layer, int step) {
	
	return (((layer_A_step_2_mixing_threshold * float(step == 2) + layer_A_step_3_mixing_threshold * float(step == 3) + layer_A_step_4_mixing_threshold * float(step == 4) + layer_A_step_5_mixing_threshold * float(step == 5))) * float(layer == 1)) + (((layer_B_step_2_mixing_threshold * float(step == 2) + layer_B_step_3_mixing_threshold * float(step == 3) + layer_B_step_4_mixing_threshold * float(step == 4) + layer_B_step_5_mixing_threshold * float(step == 5))) * float(layer == 2)) + (((layer_C_step_2_mixing_threshold * float(step == 2) + layer_C_step_3_mixing_threshold * float(step == 3) + layer_C_step_4_mixing_threshold * float(step == 4) + layer_C_step_5_mixing_threshold * float(step == 5))) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return (layer_A_step_2_mixing_threshold * float(step == 2) + layer_A_step_3_mixing_threshold * float(step == 3) + layer_A_step_4_mixing_threshold * float(step == 4) + layer_A_step_5_mixing_threshold * float(step == 5));
		//case 2:
			//return (layer_B_step_2_mixing_threshold * float(step == 2) + layer_B_step_3_mixing_threshold * float(step == 3) + layer_B_step_4_mixing_threshold * float(step == 4) + layer_B_step_5_mixing_threshold * float(step == 5));
		//case 3:
			//return (layer_C_step_2_mixing_threshold * float(step == 2) + layer_C_step_3_mixing_threshold * float(step == 3) + layer_C_step_4_mixing_threshold * float(step == 4) + layer_C_step_5_mixing_threshold * float(step == 5));
	//}
}

float get_layer_mask_amplification(int layer) {
	
	return ((layer_A_mask_amplification) * float(layer == 1)) + ((layer_B_mask_amplification) * float(layer == 2)) + ((layer_C_mask_amplification) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_mask_amplification;
		//case 2:
			//return layer_B_mask_amplification;
		//case 3:
			//return layer_C_mask_amplification;
	//}
}

float get_layer_mask_post_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			{
			vec2 color_ramp_factor = textureLod(layer_A_post_color_ramp, vec2((factor * 0.98) + 0.01, 0.0), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
			}
		case 2: 
			{
			vec2 color_ramp_factor = textureLod(layer_B_post_color_ramp, vec2((factor * 0.98) + 0.01, 0.0), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
			}
		case 3:
			{
			vec2 color_ramp_factor = textureLod(layer_C_post_color_ramp, vec2((factor * 0.98) + 0.01, 0.0), 5).ra;
			return mix(0.0, color_ramp_factor.x, color_ramp_factor.y * factor);
			}
	}
	//end ignore_sc
}

int get_layer_post_effect(int layer) {
	
	return ((layer_A_post_effect) * int(layer == 1)) + ((layer_B_post_effect) * int(layer == 2)) + ((layer_C_post_effect) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_post_effect;
		//case 2:
			//return layer_B_post_effect;
		//case 3:
			//return layer_C_post_effect;
	//}
}

float get_layer_post_effect_parameter(int layer, int parameter_index) {
	
	return ((layer_A_post_effect_parameter_1 * float(parameter_index == 1) + layer_A_post_effect_parameter_2 * float(parameter_index == 2) + layer_A_post_effect_parameter_3 * float(parameter_index == 3)) * float(layer == 1)) + ((layer_B_post_effect_parameter_1 * float(parameter_index == 1) + layer_B_post_effect_parameter_2 * float(parameter_index == 2) + layer_B_post_effect_parameter_3 * float(parameter_index == 3)) * float(layer == 2)) + ((layer_C_post_effect_parameter_1 * float(parameter_index == 1) + layer_C_post_effect_parameter_2 * float(parameter_index == 2) + layer_C_post_effect_parameter_3 * float(parameter_index == 3)) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_post_effect_parameter_1 * float(parameter_index == 1) + layer_A_post_effect_parameter_2 * float(parameter_index == 2) + layer_A_post_effect_parameter_3 * float(parameter_index == 3);
		//case 2:
			//return layer_B_post_effect_parameter_1 * float(parameter_index == 1) + layer_B_post_effect_parameter_2 * float(parameter_index == 2) + layer_B_post_effect_parameter_3 * float(parameter_index == 3);
		//case 3:
			//return layer_C_post_effect_parameter_1 * float(parameter_index == 1) + layer_C_post_effect_parameter_2 * float(parameter_index == 2) + layer_C_post_effect_parameter_3 * float(parameter_index == 3);
	//}
}

vec4 get_layer_texture_mask_texture(int layer, int a_or_b, vec2 uv) {
	switch (layer) {
		case 1:
			{
			switch (a_or_b) {
 				case 0: 
					{return textureLod(layer_A_texture_mask_A, uv, layer_A_lod_level + get_mip_modifier());}
				default:
					{return textureLod(layer_A_texture_mask_B, uv, layer_A_lod_level + get_mip_modifier());};
				}
			}
		case 2:
			switch (a_or_b) {
 				case 0: 
					return textureLod(layer_B_texture_mask_A, uv, layer_B_lod_level + get_mip_modifier());
				default:
					return textureLod(layer_B_texture_mask_B, uv, layer_B_lod_level + get_mip_modifier());
			}
		case 3:
			switch (a_or_b) { 
 				case 0: 
					return textureLod(layer_C_texture_mask_A, uv, layer_C_lod_level + get_mip_modifier());
				default:
					return textureLod(layer_C_texture_mask_B, uv, layer_C_lod_level + get_mip_modifier());
			}
	};
	//end ignore_sc
}

bool get_layer_texture_mask_enabled(int layer, int a_or_b) {

	return ((layer_A_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_A_texture_mask_B_enabled && (bool(a_or_b) == true)) && layer == 1) || ((layer_B_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_B_texture_mask_B_enabled && (bool(a_or_b) == true)) && layer == 2) || ((layer_C_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_C_texture_mask_B_enabled && (bool(a_or_b) == true)) && layer == 3);
	
	//switch (layer) {
		//case 1:
			//return layer_A_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_A_texture_mask_B_enabled && (bool(a_or_b) == true);
		//case 2:
			//return layer_B_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_B_texture_mask_B_enabled && (bool(a_or_b) == true);
		//case 3:
			//return layer_C_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_C_texture_mask_B_enabled && (bool(a_or_b) == true);
	//}
}

int get_layer_texture_masks_subtraction_order(int layer) {
	
	return ((layer_A_texture_masks_subtraction_order) * int(layer == 1)) + ((layer_B_texture_masks_subtraction_order) * int(layer == 2)) + ((layer_C_texture_masks_subtraction_order) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_texture_masks_subtraction_order;
		//case 2:
			//return layer_B_texture_masks_subtraction_order;
		//case 3:
			//return layer_C_texture_masks_subtraction_order;
	//}
}

int get_layer_texture_mask_mix_operation(int layer) {
	
	return ((layer_A_texture_masks_mix_operation) * int(layer == 1)) + ((layer_B_texture_masks_mix_operation) * int(layer == 2)) + ((layer_C_texture_masks_mix_operation) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_texture_masks_mix_operation;
		//case 2:
			//return layer_B_texture_masks_mix_operation;
		//case 3:
			//return layer_C_texture_masks_mix_operation;
	//}
}

float get_layer_texture_mask_color_ramp_value(int layer, float factor, int a_or_b) {
	switch (layer) {
		case 1: 
			{
			vec2 color_ramp_factor;
			switch (a_or_b) {
 				case 0: 
					color_ramp_factor = textureLod(layer_A_texture_mask_A_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
					break;	
				case 1:
					color_ramp_factor = textureLod(layer_A_texture_mask_B_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
			};
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		}
		case 2: {
			vec2 color_ramp_factor;
			switch (a_or_b) {
 				case 0: 
					color_ramp_factor = textureLod(layer_B_texture_mask_A_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
					break;
				case 1:
					color_ramp_factor = textureLod(layer_B_texture_mask_B_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
			};
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		}
		case 3:  {
			vec2 color_ramp_factor;
			switch (a_or_b) {
 				case 0: 
					color_ramp_factor = textureLod(layer_C_texture_mask_A_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
					break;
				case 1:
					color_ramp_factor = textureLod(layer_C_texture_mask_B_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
			};
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		}
	}
	//end ignore_sc
}

int get_layer_directional_mask_mode(int layer) {
	
	return ((layer_A_directional_mask_mode) * int(layer == 1)) + ((layer_B_directional_mask_mode) * int(layer == 2)) + ((layer_C_directional_mask_mode) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_directional_mask_mode;
		//case 2:
			//return layer_B_directional_mask_mode;
		//case 3:
			//return layer_C_directional_mask_mode;
	//}
}

int get_layer_directional_mask_space(int layer) {
	
	return ((layer_A_directional_mask_space) * int(layer == 1)) + ((layer_B_directional_mask_space) * int(layer == 2)) + ((layer_C_directional_mask_space) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_directional_mask_space;
		//case 2:
			//return layer_B_directional_mask_space;
		//case 3:
			//return layer_C_directional_mask_space;
	//}
}

float get_layer_directional_mask_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec2 color_ramp_factor = textureLod(layer_A_directional_mask_color_ramp, vec2((factor * 0.98) + 0.0), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 2:
			vec2 color_ramp_factor = textureLod(layer_B_directional_mask_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 3:
			vec2 color_ramp_factor = textureLod(layer_C_directional_mask_color_ramp, vec2((factor * 0.98) + 0.01), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
	}
	//end ignore_sc
}

int get_layer_positional_mask_mode(int layer) {
	
	return (layer_A_positional_mask_mode * int(layer == 1)) + (layer_B_positional_mask_mode * int(layer == 2)) + (layer_C_positional_mask_mode * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_positional_mask_mode;
		//case 2:
			//return layer_B_positional_mask_mode;
		//case 3:
			//return layer_C_positional_mask_mode;
	//}
}

int get_layer_positional_mask_axis(int layer) {
	
	return ((layer_A_positional_mask_axis) * int(layer == 1)) + ((layer_B_positional_mask_axis) * int(layer == 2)) + ((layer_C_positional_mask_axis) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_positional_mask_axis;
		//case 2:
			//return layer_B_positional_mask_axis;
		//case 3:
			//return layer_C_positional_mask_axis;
	//}
}

float get_layer_positional_mask_min(int layer) {
	
	return ((layer_A_positional_mask_min) * float(layer == 1)) + ((layer_B_positional_mask_min) * float(layer == 2)) + ((layer_C_positional_mask_min) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_positional_mask_min;
		//case 2:
			//return layer_B_positional_mask_min;
		//case 3:
			//return layer_C_positional_mask_min;
	//}
}

float get_layer_positional_mask_max(int layer) {
	
	return ((layer_A_positional_mask_max) * float(layer == 1)) + ((layer_B_positional_mask_max) * float(layer == 2)) + ((layer_C_positional_mask_max) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_positional_mask_max;
		//case 2:
			//return layer_B_positional_mask_max;
		//case 3:
			//return layer_C_positional_mask_max;
	//}
}

float get_layer_positional_mask_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec2 color_ramp_factor = textureLod(layer_A_positional_mask_color_ramp, vec2((factor * 0.98) + 0.1, 0.0), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 2:
			vec2 color_ramp_factor = textureLod(layer_B_positional_mask_color_ramp, vec2((factor * 0.98) + 0.1, 0.0), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 3:
			vec2 color_ramp_factor = textureLod(layer_C_positional_mask_color_ramp, vec2((factor * 0.98) + 0.1, 0.0), 5).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
	}
	//end ignore_sc
}

int get_layer_vertex_color_mask_mode(int layer) {
	
	return ((layer_A_vertex_color_mask_mode) * int(layer == 1)) + ((layer_B_vertex_color_mask_mode) * int(layer == 2)) + ((layer_C_vertex_color_mask_mode) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_vertex_color_mask_mode;
		//case 2:
			//return layer_B_vertex_color_mask_mode;
		//case 3:
			//return layer_C_vertex_color_mask_mode;
	//}
}

float get_layer_vertex_color_mask_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec4 color_ramp_color = textureLod(layer_A_vertex_color_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0), 5);
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
		case 2:
			vec4 color_ramp_color = textureLod(layer_B_vertex_color_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0), 5);
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
		case 3:
			vec4 color_ramp_color = textureLod(layer_C_vertex_color_mask_color_ramp, vec2((factor * 0.98) + 0.01, 0), 5);
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
	}
	//end ignore_sc
}

int get_layer_normal_map_slope_mask_mode(int layer) {
	
	return ((layer_A_normal_map_slope_mask_mode) * int(layer == 1)) + ((layer_B_normal_map_slope_mask_mode) * int(layer == 2)) + ((layer_C_normal_map_slope_mask_mode) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_normal_map_slope_mask_mode;
		//case 2:
			//return layer_B_normal_map_slope_mask_mode;
		//case 3:
			//return layer_C_normal_map_slope_mask_mode;
	//}
}

float get_layer_normal_map_slope_mask_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec4 color_ramp_color = textureLod(layer_A_normal_map_slope_mask_color_ramp, vec2((factor * 0.98) + 0.1, 0.0), 5);
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
		case 2:
			vec4 color_ramp_color = textureLod(layer_B_normal_map_slope_mask_color_ramp, vec2((factor * 0.98) + 0.1, 0.0), 5);
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
		case 3:
			vec4 color_ramp_color = textureLod(layer_C_normal_map_slope_mask_color_ramp, vec2((factor * 0.98) + 0.1, 0.0), 5);
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
	}
	//end ignore_sc
}

bool get_layer_uv_mask_enabled(int layer) {
	
	return ((layer_A_UV_mask_enabled) && layer == 1) || ((layer_B_UV_mask_enabled) && layer == 2) || ((layer_C_UV_mask_enabled) && layer == 3);
	
	//switch (layer) {
		//case 1:
			//return layer_A_UV_mask_enabled;
		//case 2:
			//return layer_B_UV_mask_enabled;
		//case 3:
			//return layer_C_UV_mask_enabled;
	//}
}

int get_layer_uv_mask_mixing_operation(int layer) {
	
	return ((layer_A_UV_mask_XY_mixing_operation) * int(layer == 1)) + ((layer_B_UV_mask_XY_mixing_operation) * int(layer == 2)) + ((layer_C_UV_mask_XY_mixing_operation) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_UV_mask_XY_mixing_operation;
		//case 2:
			//return layer_B_UV_mask_XY_mixing_operation;
		//case 3:
			//return layer_C_UV_mask_XY_mixing_operation;
	//}
}

int get_layer_uv_mask_mixing_order(int layer) {
	
	return ((layer_A_UV_mask_XY_mixing_order) * int(layer == 1)) + ((layer_B_UV_mask_XY_mixing_order) * int(layer == 2)) + ((layer_C_UV_mask_XY_mixing_order) * int(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_UV_mask_XY_mixing_order;
		//case 2:
			//return layer_B_UV_mask_XY_mixing_order;
		//case 3:
			//return layer_C_UV_mask_XY_mixing_order;
	//}
}

float get_layer_uv_mask_color_ramp_value(int layer, bool axis, float factor) {
	switch (layer) {
		case 1:
			vec4 color_ramp_color;
			if (axis) {
				color_ramp_color = textureLod(layer_A_UV_mask_X_color_ramp, vec2((factor * 0.98) + 0.01), 5);
			}
			else {
				color_ramp_color = textureLod(layer_A_UV_mask_Y_color_ramp, vec2((factor * 0.98) + 0.01), 5);
			}
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
		case 2:
			vec4 color_ramp_color;
			if (axis) {
				color_ramp_color = textureLod(layer_B_UV_mask_X_color_ramp, vec2((factor * 0.98) + 0.01), 5);
			}
			else {
				color_ramp_color = textureLod(layer_B_UV_mask_Y_color_ramp, vec2((factor * 0.98) + 0.01), 5);
			}
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
		case 3:
			vec4 color_ramp_color;
			if (axis) {
				color_ramp_color = textureLod(layer_C_UV_mask_X_color_ramp, vec2((factor * 0.98) + 0.01), 5);
			}
			else {
				color_ramp_color = textureLod(layer_C_UV_mask_Y_color_ramp, vec2((factor * 0.98) + 0.01), 5);
			}
			return mix(factor, color_ramp_color.r, color_ramp_color.a);
	}
	//end ignore_sc
}

float get_layer_uv_mask_min(int layer, bool axis) {
	
	return ((layer_A_UV_mask_X_min * float(int(axis) == 0) + layer_A_UV_mask_Y_min * float(int(axis) == 1)) * float(layer == 1)) + ((layer_B_UV_mask_X_min * float(int(axis) == 0) + layer_B_UV_mask_Y_min * float(int(axis) == 1)) * float(layer == 2)) + ((layer_C_UV_mask_X_min * float(int(axis) == 0) + layer_C_UV_mask_Y_min * float(int(axis) == 1)) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_UV_mask_X_min * float(int(axis) == 0) + layer_A_UV_mask_Y_min * float(int(axis) == 1);
		//case 2:
			//return layer_B_UV_mask_X_min * float(int(axis) == 0) + layer_B_UV_mask_Y_min * float(int(axis) == 1);
		//case 3:
			//return layer_C_UV_mask_X_min * float(int(axis) == 0) + layer_C_UV_mask_Y_min * float(int(axis) == 1);
	//}
}

float get_layer_uv_mask_max(int layer, bool axis) {
	
	return ((layer_A_UV_mask_X_max * float(int(axis) == 0) + layer_A_UV_mask_Y_max * float(int(axis) == 1)) * float(layer == 1)) + ((layer_B_UV_mask_X_max * float(int(axis) == 0) + layer_B_UV_mask_Y_max * float(int(axis) == 1)) * float(layer == 2)) + ((layer_C_UV_mask_X_max * float(int(axis) == 0) + layer_C_UV_mask_Y_max * float(int(axis) == 1)) * float(layer == 3));
	
	//switch (layer) {
		//case 1:
			//return layer_A_UV_mask_X_max * float(int(axis) == 0) + layer_A_UV_mask_Y_max * float(int(axis) == 1);
		//case 2:
			//return layer_B_UV_mask_X_max * float(int(axis) == 0) + layer_B_UV_mask_Y_max * float(int(axis) == 1);
		//case 3:
			//return layer_C_UV_mask_X_max * float(int(axis) == 0) + layer_C_UV_mask_Y_max * float(int(axis) == 1);
	//}
}

//======================================================================




float get_texture_mask_for_layer(int layer, vec2 mask_a_uv, vec2 mask_b_uv) {
	float texture_mask_mix;

	vec4 texture_mask_A_texture = get_layer_texture_mask_texture(layer, 0, mask_a_uv);
	vec4 texture_mask_B_texture = get_layer_texture_mask_texture(layer, 1, mask_b_uv);
	vec4 texture_mask_A_factor = vec4(get_layer_texture_mask_color_ramp_value(layer, texture_mask_A_texture.r, 0));
	vec4 texture_mask_B_factor = vec4(get_layer_texture_mask_color_ramp_value(layer, texture_mask_B_texture.r, 1));

	int texture_masks_subtraction_order = get_layer_texture_masks_subtraction_order(layer);

	bool texture_mask_A_enabled = get_layer_texture_mask_enabled(layer, 0);
	bool texture_mask_B_enabled = get_layer_texture_mask_enabled(layer, 1);

	switch (get_layer_texture_mask_mix_operation(layer)) {
		case 0:
			texture_mask_mix = (texture_mask_A_factor.r * texture_mask_A_factor.a * float(texture_mask_A_enabled)) + (texture_mask_B_factor.r * texture_mask_B_factor.a * float(texture_mask_B_enabled));
			break;
		case 1:
			switch (texture_masks_subtraction_order) {
				case 0:
					texture_mask_mix = (texture_mask_A_factor.r * texture_mask_A_factor.a * float(texture_mask_A_enabled)) - (texture_mask_B_factor.r * texture_mask_B_factor.a * float(texture_mask_B_enabled));
					break;
				case 1:
					texture_mask_mix = (texture_mask_B_factor.r * texture_mask_B_factor.a * float(texture_mask_B_enabled)) - (texture_mask_A_factor.r * texture_mask_A_factor.a * float(texture_mask_A_enabled));
					break;
			}
			break;
		case 2:
			texture_mask_mix = texture_mask_A_factor.r * texture_mask_B_factor.r;
			break;
	}

	return texture_mask_mix;
}

float get_directional_mask_for_layer(int layer, vec3 local_surface_normal, vec3 global_surface_normal) {
		vec3 surface_normal = local_surface_normal * float(get_layer_directional_mask_space(layer) == 1) + global_surface_normal * float(get_layer_directional_mask_space(layer) == 0);
		switch (get_layer_directional_mask_mode(layer)) {
			case 0:
				return 0.0;
			case 1:
				return (abs(surface_normal.r) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.r)));
			case 2:
				return (clamp(surface_normal.r, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.r, 0.0, 1.0)));
			case 3:
				return (abs(clamp(surface_normal.r, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.r, -1.0, 0.0))));
			case 4:
				return (abs(surface_normal.g) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.g)));
			case 5:
				return (clamp(surface_normal.g, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.g, 0.0, 1.0)));
			case 6:
				return (abs(clamp(surface_normal.g, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.g, -1.0, 0.0))));
			case 7:
				return (abs(surface_normal.b) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.b)));
			case 8:
				return (clamp(surface_normal.b, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.b, 0.0, 1.0)));
			case 9:
				return (abs(clamp(surface_normal.b, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.b, -1.0, 0.0))));
			}
}

float get_positional_mask_for_layer(int layer, vec3 local_v_position, vec3 global_v_position) {
	float positional_mask_value;
	float positional_mask_max = get_layer_positional_mask_max(layer);
	float positional_mask_min = get_layer_positional_mask_min(layer);

	vec3 v_position = (float(get_layer_positional_mask_mode(layer) == 1) * local_v_position) + (float(get_layer_positional_mask_mode(layer) == 2) * global_v_position);

	switch (get_layer_positional_mask_axis(layer)) {
			case 0:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.x + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
				return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0);
			case 1:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.y + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
				return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0);
			case 2:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.z + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
				return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0);
		}
}

float get_vertex_color_mask_for_layer(int layer) {
	switch (get_layer_vertex_color_mask_mode(layer)) {
		case 0:
			return 0.0;
		case 1:
			return get_layer_vertex_color_mask_color_ramp_value(layer, vertex_color.r);
		case 2:
			return get_layer_vertex_color_mask_color_ramp_value(layer, vertex_color.g);
		case 3:
			return get_layer_vertex_color_mask_color_ramp_value(layer, vertex_color.b);
		}
}

float get_normal_map_slope_mask_for_layer(int layer, vec2 uv) {
	switch (layer) {
		case 1:
			{
			vec4 normal_map_value = textureLod(layer_A_normal, uv, layer_A_lod_level);
			float mask_value = (abs(normal_map_value.r - 0.5) * float(abs(normal_map_value.r - 0.5) > abs(normal_map_value.g - 0.5)) + abs(normal_map_value.g - 0.5) * float(abs(normal_map_value.r - 0.5) < abs(normal_map_value.g - 0.5))) * float(get_layer_normal_map_slope_mask_mode(1) != 0);
			return get_layer_normal_map_slope_mask_color_ramp_value(1, mask_value);
			}
		case 2:
			return 0.0;
		case 3:
			return 0.0;
	}
	//end ignore_sc
}

float get_uv_mask_for_layer(int layer, vec2 uv) {
	float x_max = get_layer_uv_mask_max(layer, false);
	float x_min = get_layer_uv_mask_min(layer, false);
	float x_factor = clamp(1.0/(x_max - x_min) * uv.x + (1.0 - 1.0/(x_max - x_min) * x_max), 0.002, 0.998);
	float x_value = get_layer_uv_mask_color_ramp_value(layer, false, x_factor);

	float y_max = get_layer_uv_mask_max(layer, true);
	float y_min = get_layer_uv_mask_min(layer, true);
	float y_factor = clamp(1.0/(y_max - y_min) * uv.y + (1.0 - 1.0/(y_max - y_min) * y_max), 0.002, 0.998);
	float y_value = get_layer_uv_mask_color_ramp_value(layer, true, y_factor);

	float result;

	switch (get_layer_uv_mask_mixing_operation(layer)) {
		case 0:
			result = y_value + x_value;
			break;
		case 1:
			switch (get_layer_uv_mask_mixing_order(layer)) {
				case 0:
					result = x_value - y_value;
					break;
				case 1:
					result = y_value - x_value;
			};
			break;
		case 2:
			result = y_value * x_value;
			break;
	};

	return result * float(get_layer_uv_mask_enabled(layer));
}

float get_layer_mask_step_mix(int layer, int step, vec2 uv1, vec2 uv2, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position) {
	vec2 mask_a_uv = (uv1 * float(get_layer_map_uv_index(layer, 5) == 0) + uv2 * float(get_layer_map_uv_index(layer, 5) == 1)) * float(layer == 1) + (uv1 * float(get_layer_map_uv_index(layer, 5) == 0) + uv2 * float(get_layer_map_uv_index(layer, 5) == 1)) * float(layer == 2) + (uv1 * float(get_layer_map_uv_index(layer, 5) == 0) + uv2 * float(get_layer_map_uv_index(layer, 5) == 1)) * float(layer == 3);
	vec2 mask_b_uv = (uv1 * float(get_layer_map_uv_index(layer, 6) == 0) + uv2 * float(get_layer_map_uv_index(layer, 6) == 1)) * float(layer == 1) + (uv1 * float(get_layer_map_uv_index(layer, 6) == 0) + uv2 * float(get_layer_map_uv_index(layer, 6) == 1)) * float(layer == 2) + (uv1 * float(get_layer_map_uv_index(layer, 6) == 0) + uv2 * float(get_layer_map_uv_index(layer, 6) == 1)) * float(layer == 3);

	vec2 uv_mask_uv = (uv1 * float(get_layer_map_uv_index(layer, 7) == 0) + uv2 * float(get_layer_map_uv_index(layer, 7) == 1));

	vec2 normal_map_uv = uv1 * float(get_layer_map_uv_index(layer, 0) == 0) + uv2 * float(get_layer_map_uv_index(layer, 0) == 1);

	return clamp((get_texture_mask_for_layer(layer, mask_a_uv, mask_b_uv) * float(get_layer_mask_mixing_step(layer, 1) == step) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == step) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == step) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == step) + get_normal_map_slope_mask_for_layer(layer, normal_map_uv) * float(get_layer_mask_mixing_step(layer, 5) == step) + get_uv_mask_for_layer(layer, uv_mask_uv) * float(get_layer_mask_mixing_step(layer, 6) == step)), 0.0, 1.0);
}

float get_resulting_mask_for_layer(int layer, vec2 uv1, vec2 uv2, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position) {
	float step_1_mix = get_layer_mask_step_mix(layer, 1, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);

	float step_2_mix = get_layer_mask_step_mix(layer, 2, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_layer_step_mixing_operation(layer, 2)) {
		case 0:
			step_2_mix = clamp(step_1_mix + (step_2_mix * float(step_1_mix >= get_layer_step_mixing_threshold(layer, 2))), 0.0, 1.0);
			break;
		case 1:
			step_2_mix = clamp(step_1_mix - (step_2_mix * float(step_1_mix >= get_layer_step_mixing_threshold(layer, 2))), 0.0, 1.0);
			break;
		case 2:
			if (step_1_mix >= get_layer_step_mixing_threshold(layer, 2)) {
				step_2_mix = clamp(step_1_mix * step_2_mix, 0.0, 1.0);
			}
			else {
				step_2_mix = step_1_mix;
				}
			break;
	}

	float step_3_mix = get_layer_mask_step_mix(layer, 3, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_layer_step_mixing_operation(layer, 3)) {
		case 0:
			step_3_mix = clamp(step_2_mix + (step_3_mix * float(step_2_mix >= get_layer_step_mixing_threshold(layer, 3))), 0.0, 1.0);
			break;
		case 1:
			step_3_mix = clamp(step_2_mix - (step_3_mix * float(step_2_mix >= get_layer_step_mixing_threshold(layer, 3))), 0.0, 1.0);
			break;
		case 2:
			if (step_2_mix >= get_layer_step_mixing_threshold(layer, 3)) {
				step_3_mix = clamp(step_2_mix * step_3_mix, 0.0, 1.0);
			}
			else {
				step_3_mix = step_2_mix;
				}
			break;
	}

	float step_4_mix = get_layer_mask_step_mix(layer, 4, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_layer_step_mixing_operation(layer, 4)) {
		case 0:
			step_4_mix = clamp(step_3_mix + (step_4_mix * float(step_3_mix >= get_layer_step_mixing_threshold(layer, 4))), 0.0, 1.0);
			break;
		case 1:
			step_4_mix = clamp(step_3_mix - (step_4_mix * float(step_3_mix >= get_layer_step_mixing_threshold(layer, 4))), 0.0, 1.0);
			break;
		case 2:
			if (step_3_mix >= get_layer_step_mixing_threshold(layer, 4)) {
				step_4_mix = clamp(step_3_mix * step_4_mix, 0.0, 1.0);
			}
			else {
				step_4_mix = step_3_mix;
				}
			break;
	}

	float step_5_mix = get_layer_mask_step_mix(layer, 5, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_layer_step_mixing_operation(layer, 5)) {
		case 0:
			step_5_mix = clamp(step_4_mix + (step_5_mix * float(step_4_mix >= get_layer_step_mixing_threshold(layer, 5))), 0.0, 1.0);
			break;
		case 1:
			step_5_mix = clamp(step_4_mix - (step_5_mix * float(step_4_mix >= get_layer_step_mixing_threshold(layer, 5))), 0.0, 1.0);
			break;
		case 2:
			if (step_4_mix >= get_layer_step_mixing_threshold(layer, 5)) {
				step_5_mix = clamp(step_4_mix * step_5_mix, 0.0, 1.0);
			}
			else {
				step_5_mix = step_4_mix;
				}
			break;
	}

	float step_6_mix = get_layer_mask_step_mix(layer, 6, uv1, uv2, local_surface_normal, global_surface_normal, local_vertex_position, global_vertex_position);
	switch (get_layer_step_mixing_operation(layer, 6)) {
		case 0:
			step_6_mix = clamp(step_4_mix + (step_6_mix * float(step_5_mix >= get_layer_step_mixing_threshold(layer, 6))), 0.0, 1.0);
			break;
		case 1:
			step_6_mix = clamp(step_4_mix - (step_6_mix * float(step_5_mix >= get_layer_step_mixing_threshold(layer, 6))), 0.0, 1.0);
			break;
		case 2:
			if (step_5_mix >= get_layer_step_mixing_threshold(layer, 6)) {
				step_6_mix = clamp(step_5_mix * step_6_mix, 0.0, 1.0);
			}
			else {
				step_6_mix = step_5_mix;
				}
			break;
	}

	switch (get_layer_post_effect(layer)) {
		case 1:
			step_6_mix = step_6_mix + 0.1;
			break;
		case 2:
			step_6_mix = 0.0;
			break;
	};

	//return step_3_mix;
	return get_layer_mask_post_color_ramp_value(layer, clamp(step_5_mix, 0.0, 1.0) * get_layer_mask_amplification(layer) + 0.002);
}



//==========================================================================



void vertex() {
	switch (vertex_displacement_mode) {
		case 1:
			VERTEX.xyz += NORMAL.xyz * vertex_displacement_scale * texture(vertex_displacement_map, UV).r;
			break;
	}
	local_vertex_normal = NORMAL.rgb;
	global_vertex_normal = local_vertex_normal * MODEL_NORMAL_MATRIX;
	local_vertex_pos = VERTEX.xyz;
	global_vertex_pos = (vec4(local_vertex_pos, 1.0) * MODEL_MATRIX).xyz;
	global_camera_pos = CAMERA_POSITION_WORLD;
}

void fragment() {
	vertex_color = COLOR.rgb;
	
	float mip_modifier = get_mip_modifier();
	
//ignore
	vec4 layer_base_albedo_texture = texture(layer_base_albedo, (UV + layer_base_uv_offset) * layer_base_uv_scale);
	float layer_base_occlusion_factor = texture(layer_base_occlusion_map, (UV + layer_base_uv_offset) * layer_base_uv_scale).r;
	float layer_base_roughness_factor = texture(layer_base_roughness_map, (UV + layer_base_uv_offset) * layer_base_uv_scale).r;
	float layer_base_metallic_factor = texture(layer_base_metallic_map, (UV + layer_base_uv_offset) * layer_base_uv_scale).r;
	vec3 layer_base_normal_map = texture(layer_base_normal, (UV + layer_base_uv_offset) * layer_base_uv_scale).rgb;

	vec3 albedo_mix = layer_base_albedo_texture.rgb;
	float occlusion_mix = layer_base_occlusion_factor;
	float roughness_mix = layer_base_roughness_factor;
	float metallic_mix = layer_base_metallic_factor;
	vec3 normal_mix = layer_base_normal_map;

	int layer_bottom_assigned_layer = get_processing_layer_assigned_layer(1);
	int layer_middle_assigned_layer = get_processing_layer_assigned_layer(2);
	int layer_top_assigned_layer = get_processing_layer_assigned_layer(3);
//end ignore

//include
	//vec3 albedo_mix = vec3(0.0, 0.0, 0.0);
	//float occlusion_mix = 0.0;
	//float roughness_mix = 0.5;
	//float metallic_mix = 0.0;
	//vec3 normal_mix = vec3(0.5, 1.0, 0.5);
	//%layer_fragment_snippets
//end include

//end base_string

//fragment_snippet_string
	if (layer_A_enabled == true) {
		vec3 uv1_triplanar_pos;
		vec3 uv1_triplanar_normal;

		if (get_layer_uv_triplanar_mode(1, 0) == 0) {
			uv1_triplanar_pos = local_vertex_pos;
			uv1_triplanar_normal = local_vertex_normal;
		}
		else {
			uv1_triplanar_pos = global_vertex_pos;
			uv1_triplanar_normal = global_vertex_normal;
		}

		vec2 uv1;
		if (get_layer_uv_mode(1, 0) == 0) uv1 = get_layer_uv(1, 0, UV);
		else uv1 = get_layer_triplanar_uv(1, 0, uv1_triplanar_pos, uv1_triplanar_normal, UV);

		vec3 uv2_triplanar_pos;
		vec3 uv2_triplanar_normal;

		if (get_layer_uv_triplanar_mode(1, 1) == 0) {
			uv2_triplanar_pos = local_vertex_pos;
			uv2_triplanar_normal = local_vertex_normal;
		}
		else {
			uv2_triplanar_pos = global_vertex_pos;
			uv2_triplanar_normal = global_vertex_normal;
		}

		vec2 uv2;
		if (get_layer_uv_mode(1, 1) == 0) uv2 = get_layer_uv(1, 0, UV);
		else uv2 = get_layer_triplanar_uv(1, 1, uv2_triplanar_pos, uv2_triplanar_normal, UV);

		int layer_A_normal_uv_map_index = get_layer_map_uv_index(1,0);
		int layer_A_albedo_uv_map_index = get_layer_map_uv_index(1,1);
		int layer_A_occlusion_uv_map_index = get_layer_map_uv_index(1,2);
		int layer_A_roughness_uv_map_index = get_layer_map_uv_index(1,3);
		int layer_A_metallic_uv_map_index = get_layer_map_uv_index(1,4);
		
		vec4 layer_A_albedo_texture = textureLod(layer_A_albedo, uv1 * float(layer_A_albedo_uv_map_index == 0) + uv2 * float(layer_A_albedo_uv_map_index == 1), layer_A_lod_level + mip_modifier);
		vec2 layer_A_occlusion_factor;
		vec2 layer_A_roughness_factor;
		vec2 layer_A_metallic_factor;
		
		switch (layer_A_orm_mode) {
			case 0:
				vec4 orm_color = textureLod(layer_A_orm_map, uv1 * float(layer_A_occlusion_uv_map_index == 0) + uv2 * float(layer_A_occlusion_uv_map_index == 1), layer_A_lod_level + mip_modifier);
				layer_A_occlusion_factor = orm_color.ra;
				layer_A_roughness_factor = orm_color.ga;
				layer_A_metallic_factor = orm_color.ba;
				break;
			case 1:
				layer_A_occlusion_factor = textureLod(layer_A_occlusion_map, uv1 * float(layer_A_occlusion_uv_map_index == 0) + uv2 * float(layer_A_occlusion_uv_map_index == 1), layer_A_lod_level + mip_modifier).ra;
				layer_A_roughness_factor = textureLod(layer_A_roughness_map, uv1 * float(layer_A_roughness_uv_map_index == 0) + uv2 * float(layer_A_roughness_uv_map_index == 1), layer_A_lod_level + mip_modifier).ra;
				layer_A_metallic_factor = textureLod(layer_A_metallic_map, uv1 * float(layer_A_metallic_uv_map_index == 0) + uv2 * float(layer_A_metallic_uv_map_index == 1), layer_A_lod_level + mip_modifier).ra;
				break;
			default:
				layer_A_occlusion_factor = vec2(layer_A_occlusion_value, 1.0);
				layer_A_roughness_factor = vec2(layer_A_roughness_value, 1.0);
				layer_A_metallic_factor = vec2(layer_A_metallic_value, 1.0);
		};
		
		vec3 layer_A_normal_map = textureLod(layer_A_normal, uv1 * float(layer_A_normal_uv_map_index == 0) + uv2 * float(layer_A_normal_uv_map_index == 1), layer_A_lod_level + mip_modifier).rgb;

		int mask_A_uv_map_index = get_layer_map_uv_index(1, 5);
		int mask_B_uv_map_index = get_layer_map_uv_index(1, 6);

		float layer_A_mask_factor = get_resulting_mask_for_layer(1, uv1, uv2, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos);
		albedo_mix = mix(albedo_mix, layer_A_albedo_texture.rgb, layer_A_mask_factor * layer_A_albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(layer_A_mask_factor), float(layer_A_consolidate_masks));

		occlusion_mix = mix(occlusion_mix, layer_A_occlusion_factor.x, layer_A_mask_factor * layer_A_occlusion_factor.y);
		roughness_mix = mix(roughness_mix, layer_A_roughness_factor.x, layer_A_mask_factor * layer_A_roughness_factor.y);
		metallic_mix = mix(metallic_mix, layer_A_metallic_factor.x, layer_A_mask_factor * layer_A_metallic_factor.y);
		normal_mix = mix(normal_mix, layer_A_normal_map, layer_A_mask_factor * (1.0 - float(layer_A_propagate_normals)));
	}
//end fragment_snippet_string

	if (layer_B_enabled == true) {
		vec2 uv1 = (UV + get_layer_uv_offset(2, 0, UV) + layer_B_uv1_offset) * layer_B_uv1_scale;
		vec2 uv2 = (UV + get_layer_uv_offset(2, 1, UV) + layer_B_uv2_offset) * layer_B_uv2_scale;

		int layer_B_normal_uv_map_index = get_layer_map_uv_index(2,0);
		int layer_B_albedo_uv_map_index = get_layer_map_uv_index(2,1);
		int layer_B_occlusion_uv_map_index = get_layer_map_uv_index(2,2);
		int layer_B_roughness_uv_map_index = get_layer_map_uv_index(2,3);
		int layer_B_metallic_uv_map_index = get_layer_map_uv_index(2,4);

		vec4 layer_B_albedo_texture;
		vec2 layer_B_occlusion_factor;
		vec2 layer_B_roughness_factor;
		vec2 layer_B_metallic_factor;
		
		switch (layer_B_orm_mode) {
			case 0:
				vec4 orm_color = textureLod(layer_B_orm_map, uv1 * float(layer_B_occlusion_uv_map_index == 0) + uv2 * float(layer_B_occlusion_uv_map_index == 1), layer_B_lod_level + mip_modifier);
				layer_B_occlusion_factor = orm_color.ra;
				layer_B_roughness_factor = orm_color.ga;
				layer_B_metallic_factor = orm_color.ba;
				break;
			case 1:
				layer_B_occlusion_factor = textureLod(layer_B_occlusion_map, uv1 * float(layer_B_occlusion_uv_map_index == 0) + uv2 * float(layer_B_occlusion_uv_map_index == 1), layer_B_lod_level + mip_modifier).ra;
				layer_B_roughness_factor = textureLod(layer_B_roughness_map, uv1 * float(layer_B_roughness_uv_map_index == 0) + uv2 * float(layer_B_roughness_uv_map_index == 1), layer_B_lod_level + mip_modifier).ra;
				layer_B_metallic_factor = textureLod(layer_B_metallic_map, uv1 * float(layer_B_metallic_uv_map_index == 0) + uv2 * float(layer_B_metallic_uv_map_index == 1), layer_B_lod_level + mip_modifier).ra;
				break;
			default:
				layer_B_occlusion_factor = vec2(layer_B_occlusion_value, 1.0);
				layer_B_roughness_factor = vec2(layer_B_roughness_value, 1.0);
				layer_B_metallic_factor = vec2(layer_B_metallic_value, 1.0);
		};
		
		vec3 layer_B_normal_map = textureLod(layer_B_normal, uv1 * float(layer_B_normal_uv_map_index == 0) + uv2 * float(layer_B_normal_uv_map_index == 1), layer_B_lod_level + mip_modifier).rgb;

		int mask_A_uv_map_index = get_layer_map_uv_index(2, 5);
		int mask_B_uv_map_index = get_layer_map_uv_index(2, 6);

		float layer_B_mask_factor = get_resulting_mask_for_layer(2, uv1, uv2, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos);
		albedo_mix = mix(albedo_mix, layer_B_albedo_texture.rgb, layer_B_mask_factor * layer_B_albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(layer_B_mask_factor), float(layer_B_consolidate_masks));

		occlusion_mix = mix(occlusion_mix, layer_B_occlusion_factor.x, layer_B_mask_factor * layer_B_occlusion_factor.y);
		roughness_mix = mix(roughness_mix, layer_B_roughness_factor.x, layer_B_mask_factor * layer_B_roughness_factor.y);
		metallic_mix = mix(metallic_mix, layer_B_metallic_factor.x, layer_B_mask_factor * layer_B_metallic_factor.y);
		normal_mix = mix(normal_mix, layer_B_normal_map, layer_B_mask_factor * (1.0 - float(layer_B_propagate_normals)));
	}

	if (layer_C_enabled == true) {
		vec2 uv1 = (UV + get_layer_uv_offset(3, 0, UV) + layer_C_uv1_offset) * layer_C_uv1_scale;
		vec2 uv2 = (UV + get_layer_uv_offset(3, 1, UV) + layer_C_uv2_offset) * layer_C_uv2_scale;

		int layer_C_normal_uv_map_index = get_layer_map_uv_index(2,0);
		int layer_C_albedo_uv_map_index = get_layer_map_uv_index(2,1);
		int layer_C_occlusion_uv_map_index = get_layer_map_uv_index(2,2);
		int layer_C_roughness_uv_map_index = get_layer_map_uv_index(2,3);
		int layer_C_metallic_uv_map_index = get_layer_map_uv_index(2,4);

		vec4 layer_C_albedo_texture ;
		vec2 layer_C_occlusion_factor;
		vec2 layer_C_roughness_factor;
		vec2 layer_C_metallic_factor;
		
		switch (layer_C_orm_mode) {
			case 0:
				vec4 orm_color = textureLod(layer_C_orm_map, uv1 * float(layer_C_occlusion_uv_map_index == 0) + uv2 * float(layer_C_occlusion_uv_map_index == 1), layer_C_lod_level + mip_modifier);
				layer_C_occlusion_factor = orm_color.ra;
				layer_C_roughness_factor = orm_color.ga;
				layer_C_metallic_factor = orm_color.ba;
				break;
			case 1:
				layer_C_occlusion_factor = textureLod(layer_C_occlusion_map, uv1 * float(layer_C_occlusion_uv_map_index == 0) + uv2 * float(layer_C_occlusion_uv_map_index == 1), layer_C_lod_level + mip_modifier).ra;
				layer_C_roughness_factor = textureLod(layer_C_roughness_map, uv1 * float(layer_C_roughness_uv_map_index == 0) + uv2 * float(layer_C_roughness_uv_map_index == 1), layer_C_lod_level + mip_modifier).ra;
				layer_C_metallic_factor = textureLod(layer_C_metallic_map, uv1 * float(layer_C_metallic_uv_map_index == 0) + uv2 * float(layer_C_metallic_uv_map_index == 1), layer_C_lod_level + mip_modifier).ra;
				break;
			default:
				layer_C_occlusion_factor = vec2(layer_C_occlusion_value, 1.0);
				layer_C_roughness_factor = vec2(layer_C_roughness_value, 1.0);
				layer_C_metallic_factor = vec2(layer_C_metallic_value, 1.0);
		};
		
		vec3 layer_C_normal_map = textureLod(layer_C_normal, uv1 * float(layer_C_normal_uv_map_index == 0) + uv2 * float(layer_C_normal_uv_map_index == 1), layer_C_lod_level + mip_modifier).rgb;

		int mask_A_uv_map_index = get_layer_map_uv_index(3, 5);
		int mask_B_uv_map_index = get_layer_map_uv_index(3, 6);

		float layer_C_mask_factor = get_resulting_mask_for_layer(3, uv1, uv2, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos);
		albedo_mix = mix(albedo_mix, layer_C_albedo_texture.rgb, layer_C_mask_factor * layer_C_albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(layer_C_mask_factor), float(layer_C_consolidate_masks));

		occlusion_mix = mix(occlusion_mix, layer_C_occlusion_factor.x, layer_C_mask_factor * layer_C_occlusion_factor.y);
		roughness_mix = mix(roughness_mix, layer_C_roughness_factor.x, layer_C_mask_factor * layer_C_roughness_factor.y);
		metallic_mix = mix(metallic_mix, layer_C_metallic_factor.x, layer_C_mask_factor * layer_C_metallic_factor.y);
		normal_mix = mix(normal_mix, layer_C_normal_map, layer_C_mask_factor * (1.0 - float(layer_C_propagate_normals)));
	}

//base2_string

	switch (albedo_channel) {
		case 0:
			ALBEDO = albedo_mix.rgb;
			break;
		case 1:
			ALBEDO = vec3(roughness_mix);
			break;
		case 2:
			ALBEDO = vec3(metallic_mix);
			break;
		case 3:
			ALBEDO = normal_mix;
			break;
	};

	ROUGHNESS = roughness_mix;
	METALLIC = metallic_mix;
	NORMAL_MAP = normal_mix;
}
//end base2_string