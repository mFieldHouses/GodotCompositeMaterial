shader_type spatial;

//Todo: triplanar mapping, vertex displacement normal recalculation, implement changing order of layers (bottom, middle, top), uv rotation by uv offset map r channel, uv mask

render_mode cull_disabled, depth_draw_always;


//indeces/enums:
//
//	maps/textures:
// 		0:normal
// 		1:albedo
// 		2:occlusion
// 		3:roughness
//		4:metallic
//		5:texture mask A
//		6:texture mask B

uniform sampler2D screen_texture : hint_screen_texture, filter_linear_mipmap, repeat_disable;

group_uniforms vertex_displacement;
uniform int vertex_displacement_mode : hint_enum("Disabled", "Normal") = 0;
uniform float vertex_displacement_scale = -1.0;
uniform sampler2D vertex_displacement_map : hint_default_black;

group_uniforms layer_C;
/**
 * Whether this layer will display at all.
 */
uniform bool layer_C_enabled = true;
/**
 * In what place this layer will show. Layer 1 is the bottom layer, layer 3 the top layer. Do not set this to the same value on multiple layers.
 */
uniform int layer_C_processing_index : hint_enum("Bottom", "Middle", "Top") = 2;
/**
 * X and Y components by which the size of the UV map used by all maps (albedo, normal, ORM) will be multiplied.
 */
uniform vec2 layer_C_pbr_uv_scale = vec2(1.0);
uniform vec2 layer_C_pbr_uv_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_C_uv_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_C_uv_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_C_uv_offset_map_factor = 1.0;
uniform sampler2D layer_C_albedo : source_color, hint_default_transparent;

uniform sampler2D layer_C_normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool layer_C_propagate_normals = false;

group_uniforms layer_C.uv1;
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_C_uv1_scale = vec2(1.0);
uniform vec2 layer_C_uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_C_uv1_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_C_uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_C_uv1_offset_map_factor = 1.0;

group_uniforms layer_C.uv2;
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_C_uv2_scale = vec2(1.0);
uniform vec2 layer_C_uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_C_uv2_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_C_uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_C_uv2_offset_map_factor = 1.0;

group_uniforms layer_C.uv_map_assignment;
uniform int layer_C_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_C_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_C_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;

group_uniforms layer_C.ORM;
uniform int layer_C_orm_mode : hint_enum("Single map", "Seperate maps") = 0;
uniform sampler2D layer_C_orm_map : hint_default_transparent;
uniform sampler2D layer_C_occlusion_map : hint_default_transparent;
uniform sampler2D layer_C_roughness_map : hint_default_transparent;
uniform sampler2D layer_C_metallic_map : hint_default_transparent;
/**
 * Whether this layer should use the same ORM texture as the underlying layer.
 */
group_uniforms layer_C.masking;
/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool layer_C_consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask will be multiplied.
 */
uniform float layer_C_mask_amplification : hint_range(0.0, 10.0) = 1.0;

/**
 * By what type of operation step 1 and step 2 will be mixed.
 */
uniform int layer_C_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * From which mask value on the masks assigned to step 1, step 1 and step 2 will mix.
 */
uniform float layer_C_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_C_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_C_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D layer_C_post_color_ramp : hint_default_transparent;
uniform int layer_C_post_effect : hint_enum("None", "Drip", "Expand-Blur") = 0;
uniform float layer_C_post_effect_parameter_1 : hint_range(0.0, 1.0) = 0.1;
uniform float layer_C_post_effect_parameter_2 = 0.0;
uniform float layer_C_post_effect_parameter_3 = 0.0;

group_uniforms layer_C.texture_masks;
uniform vec2 layer_C_mask_uv_scale = vec2(1.0, 1.0);
uniform vec2 layer_C_mask_uv_offset = vec2(0.0, 0.0);
uniform bool layer_C_texture_mask_A_enabled = true;
uniform sampler2D layer_C_texture_mask_A : hint_default_transparent;
uniform bool layer_C_texture_mask_B_enabled = false;
uniform sampler2D layer_C_texture_mask_B : hint_default_transparent;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int layer_C_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int layer_C_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int layer_C_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 1;

group_uniforms layer_C.directional_mask;
/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int layer_C_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int layer_C_directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D layer_C_directional_mask_color_ramp : hint_default_transparent;
uniform int layer_C_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 2;

group_uniforms layer_C.positional_mask;
uniform int layer_C_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D layer_C_positional_mask_color_ramp : hint_default_transparent;
uniform int layer_C_positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_C_positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_C_positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int layer_C_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 3;

group_uniforms layer_C.vertex_color_mask;
/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int layer_C_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D layer_C_vertex_color_mask_color_ramp : hint_default_transparent;
uniform int layer_C_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 4;

group_uniforms layer_C.UV_mask;
uniform int layer_C_UV_mask_mode : hint_enum("Disabled", "Tile", "Clamp") = 0;

group_uniforms layer_C.normal_map_slope_mask;

uniform bool layer_C_normal_map_slope_mask_enabled = false;
uniform sampler2D layer_C_normal_map_slope_mask_color_ramp : hint_default_transparent;
uniform int layer_C_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5;

//==========================================================================


//==========================================================================




group_uniforms layer_B;
/**
 * Whether this layer will display at all.
 */
uniform bool layer_B_enabled = true;
/**
 * In what place this layer will show. Layer 1 is the bottom layer, layer 3 the top layer. Do not set this to the same value on multiple layers.
 */
uniform int layer_B_processing_index : hint_enum("Bottom", "Middle", "Top") = 1;
/**
 * X and Y components by which the size of the UV map used by all maps (albedo, normal, ORM) will be multiplied.
 */
uniform vec2 layer_B_pbr_uv_scale = vec2(1.0);
uniform vec2 layer_B_map_uv_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_B_uv_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_B_uv_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_B_uv_offset_map_factor = 1.0;

uniform sampler2D layer_B_albedo : source_color, hint_default_transparent;

uniform sampler2D layer_B_normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool layer_B_propagate_normals = false;

group_uniforms layer_B.uv1;
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_B_uv1_scale = vec2(1.0);
uniform vec2 layer_B_uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_B_uv1_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_B_uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_B_uv1_offset_map_factor = 1.0;

group_uniforms layer_B.uv2;
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_B_uv2_scale = vec2(1.0);
uniform vec2 layer_B_uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_B_uv2_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_B_uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_B_uv2_offset_map_factor = 1.0;

group_uniforms layer_B.uv_map_assignment;
uniform int layer_B_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_B_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_B_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;

group_uniforms layer_B.ORM;
uniform int layer_B_orm_mode : hint_enum("Single map", "Seperate maps") = 0;
uniform sampler2D layer_B_orm_map : hint_default_transparent;
uniform sampler2D layer_B_occlusion_map : hint_default_transparent;
uniform sampler2D layer_B_roughness_map : hint_default_transparent;
uniform sampler2D layer_B_metallic_map : hint_default_transparent;
/**
 * Whether this layer should use the same ORM texture as the underlying layer.
 */
group_uniforms layer_B.masking;
/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool layer_B_consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask (A, B and Directional) will be multiplied.
 */
uniform float layer_B_mask_amplification : hint_range(0.0, 10.0) = 1.0;

uniform int layer_B_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply", "Masked Add") = 0;
uniform float layer_B_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply", "Masked Add") = 0;
uniform float layer_B_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply", "Masked Add") = 0;
uniform float layer_B_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_B_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_B_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D layer_B_post_color_ramp : hint_default_transparent;

group_uniforms layer_B.texture_masks;
uniform vec2 layer_B_mask_uv_scale = vec2(1.0, 1.0);
uniform vec2 layer_B_mask_uv_offset = vec2(1.0, 1.0);
uniform bool layer_B_texture_mask_A_enabled = true;
uniform sampler2D layer_B_texture_mask_A : hint_default_transparent;
uniform bool layer_B_texture_mask_B_enabled = false;
uniform sampler2D layer_B_texture_mask_B : hint_default_transparent;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int layer_B_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int layer_B_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int layer_B_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 1;

group_uniforms layer_B.directional_mask;
/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int layer_B_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int layer_B_directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D layer_B_directional_mask_color_ramp : hint_default_transparent;
uniform int layer_B_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 2;

group_uniforms layer_B.positional_mask;
uniform int layer_B_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D layer_B_positional_mask_color_ramp : hint_default_transparent;
uniform int layer_B_positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_B_positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_B_positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int layer_B_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 3;


group_uniforms layer_B.vertex_color_mask;
/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int layer_B_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D layer_B_vertex_color_mask_color_ramp : hint_default_transparent;
uniform int layer_B_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 4;

group_uniforms layer_B.normal_map_slope_mask;

uniform bool layer_B_normal_map_slope_mask_enabled = false;
uniform sampler2D layer_B_normal_map_slope_mask_color_ramp : hint_default_transparent;
uniform int layer_B_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5;

//==========================================================================


//==========================================================================




group_uniforms layer_A;
/**
 * Whether this layer will display at all.
 */
uniform bool layer_A_enabled = true;
/**
 * In what place this layer will show. Layer 1 is the bottom layer, layer 3 the top layer. Do not set this to the same value on multiple layers.
 */
uniform int layer_A_processing_index : hint_enum("Bottom", "Middle", "Top") = 0;

uniform sampler2D layer_A_albedo : source_color, hint_default_transparent;

uniform sampler2D layer_A_normal : hint_normal;
/**
 * Whether this layer should use the same normal map as the underlying layer.
 */
uniform bool layer_A_propagate_normals = false;

group_uniforms layer_A.uv1;
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_A_uv1_scale = vec2(1.0);
uniform vec2 layer_A_uv1_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_A_uv1_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_A_uv1_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_A_uv1_offset_map_factor = 1.0;

group_uniforms layer_A.uv2;
/**
 * X and Y components by which the size of this UV map will be multiplied.
 */
uniform vec2 layer_A_uv2_scale = vec2(1.0);
uniform vec2 layer_A_uv2_offset = vec2(0.0);
/**
 * The Red and Green channels of this map are interpreted as U and V offsets respectively.
 */
uniform sampler2D layer_A_uv2_offset_map : hint_default_transparent, filter_nearest;
uniform vec2 layer_A_uv2_offset_map_scale = vec2(1.0, 1.0);
/**
 * Number by which the UV offsets generated by the UV offset map will be multiplied before getting added to the final UVs.
 */
uniform float layer_A_uv2_offset_map_factor = 1.0;

group_uniforms layer_A.uv_map_assignment;
uniform int layer_A_normal_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_albedo_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_occlusion_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_roughness_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_metallic_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_UV_offset_map_UV_assignment : hint_enum("UV1", "UV2") = 0;
uniform int layer_A_texture_mask_A_UV_assignment : hint_enum("UV1", "UV2") = 1;
uniform int layer_A_texture_mask_B_UV_assignment : hint_enum("UV1", "UV2") = 1;

group_uniforms layer_A.ORM;
uniform int layer_A_orm_mode : hint_enum("Single map", "Seperate maps") = 0;
uniform sampler2D layer_A_orm_map : hint_default_transparent;
uniform sampler2D layer_A_occlusion_map : hint_default_transparent;
uniform sampler2D layer_A_roughness_map : hint_default_transparent;
uniform sampler2D layer_A_metallic_map : hint_default_transparent;
/**
 * Whether this layer should use the same ORM texture as the underlying layer.
 */
group_uniforms layer_A.masking;
/**
 * Whether this layer should display only its masks in black and white.
 */
uniform bool layer_A_consolidate_masks = false;
/**
 * Number by which the intensity of the resulting mask (A, B and Directional) will be multiplied.
 */
uniform float layer_A_mask_amplification : hint_range(0.0, 10.0) = 1.0;

uniform int layer_A_step_2_mixing_operation : hint_enum("Add", "Subtract", "Multiply", "Masked Add") = 0;
uniform float layer_A_step_2_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_3_mixing_operation : hint_enum("Add", "Subtract", "Multiply", "Masked Add") = 0;
uniform float layer_A_step_3_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_4_mixing_operation : hint_enum("Add", "Subtract", "Multiply", "Masked Add") = 0;
uniform float layer_A_step_4_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_5_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_5_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform int layer_A_step_6_mixing_operation : hint_enum("Add", "Subtract", "Multiply") = 0;
uniform float layer_A_step_6_mixing_threshold : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D layer_A_post_color_ramp : hint_default_transparent;

group_uniforms layer_A.texture_masks;
uniform vec2 layer_A_mask_uv_scale = vec2(1.0, 1.0);
uniform vec2 layer_A_mask_uv_offset = vec2(1.0, 1.0);
uniform bool layer_A_texture_mask_A_enabled = true;
uniform sampler2D layer_A_texture_mask_A : hint_default_transparent;
uniform bool layer_A_texture_mask_B_enabled = false;
uniform sampler2D layer_A_texture_mask_B : hint_default_transparent;

/**
 * What operation will be executed to mix masks A and B together. Depending on the mixing operation, the "Enabled" property per mask may be ignored.
 */
uniform int layer_A_texture_masks_mix_operation: hint_enum("Add", "Subtract", "Multiply") = 0;
/**
 * In what order masks A and B will be substracted from one another when the mix mode is set to "subtract".
 */
uniform int layer_A_texture_masks_subtraction_order: hint_enum("A - B", "B - A") = 0;
uniform int layer_A_texture_masks_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 1;

group_uniforms layer_A.directional_mask;
/**
 * Whether to generate a mask which is multiplied with the direction of the normals of the mesh, dependant on the direction chosen.
 */
uniform int layer_A_directional_mask_mode : hint_enum("Disabled", "X", "X+", "X-", "Y", "Y+", "Y-", "Z", "Z+", "Z-");
uniform int layer_A_directional_mask_space : hint_enum("Global", "Local") = 0;
uniform sampler2D layer_A_directional_mask_color_ramp : hint_default_transparent;
uniform int layer_A_directional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 2;

group_uniforms layer_A.positional_mask;
uniform int layer_A_positional_mask_mode : hint_enum("Disabled", "Local", "Global") = 0;
uniform sampler2D layer_A_positional_mask_color_ramp : hint_default_transparent;
uniform int layer_A_positional_mask_axis : hint_enum("X", "Y", "Z") = 1;
/**
 * Position on the axis chosen starting at which the mask is 1. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_A_positional_mask_max = 1.0;
/**
 * Position on the axis chosen starting at which the mask is 0. Doesn't apply to the Local positional mask mode.
 */
uniform float layer_A_positional_mask_min = -1.0;
/**
 * What operation will be executed to mix masks ABD (already mixed) and the Positional Mask together.
 */
uniform int layer_A_positional_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 3;


group_uniforms layer_A.vertex_color_mask;
/**
 * Whether to use the objects vertex color properties as a mask. Useful for edgewear or adding deliberate spots of material to terrain.
 */
uniform int layer_A_vertex_color_mask_mode : hint_enum("Disabled", "Red", "Green", "Blue") = 0;
uniform sampler2D layer_A_vertex_color_mask_color_ramp : hint_default_transparent;
uniform int layer_A_vertex_color_mask_mixing_step: hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4") = 4;

group_uniforms layer_A.normal_map_slope_mask;

uniform bool layer_A_normal_map_slope_mask_enabled = false;
uniform sampler2D layer_A_normal_map_slope_mask_color_ramp : hint_default_transparent;
uniform int layer_A_normal_map_slope_mask_mixing_step : hint_enum("Step 1:1", "Step 2:2", "Step 3:3", "Step 4:4", "Step 5:5") = 5;

varying vec3 local_vertex_normal;
varying vec3 global_vertex_normal;
varying vec3 global_vertex_pos;
varying vec3 local_vertex_pos;
varying vec3 vertex_color;



//==========================================================================


//==========================================================================




int get_processing_layer_assigned_layer(int layer_processing_index) {
	if (layer_A_processing_index == layer_processing_index) {
		return 1;
	}
	else if (layer_B_processing_index == layer_processing_index) {
		return 2;
	}
	else if (layer_C_processing_index == layer_processing_index) {
		return 3;
	}
}

bool get_layer_enabled(int layer_index) {
	switch (layer_index) {
		case 1:
			return layer_A_enabled;
		case 2:
			return layer_B_enabled;
		case 3:
			return layer_C_enabled;
	}
}

vec2 get_layer_uv_offset(int layer, int uv_map_index, vec2 uv) {
	switch (layer) {
		case 1:
			return ((texture(layer_A_uv1_offset_map, uv * layer_A_uv1_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_A_uv1_offset_map, uv).a * layer_A_uv1_offset_map_factor * float(uv_map_index == 0) + ((texture(layer_A_uv2_offset_map, uv * layer_A_uv2_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_A_uv2_offset_map, uv).a * layer_A_uv2_offset_map_factor * float(uv_map_index == 1);
		case 2:
			return ((texture(layer_B_uv1_offset_map, uv * layer_B_uv1_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_B_uv1_offset_map, uv).a * layer_B_uv1_offset_map_factor * float(uv_map_index == 0) + ((texture(layer_B_uv2_offset_map, uv * layer_B_uv2_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_B_uv2_offset_map, uv).a * layer_B_uv2_offset_map_factor * float(uv_map_index == 1);
		case 3:
			return ((texture(layer_C_uv1_offset_map, uv * layer_C_uv1_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_C_uv1_offset_map, uv).a * layer_C_uv1_offset_map_factor * float(uv_map_index == 0) + ((texture(layer_C_uv2_offset_map, uv * layer_C_uv2_offset_map_scale).rg - vec2(0.5)) * 2.0) * texture(layer_C_uv2_offset_map, uv).a * layer_C_uv2_offset_map_factor * float(uv_map_index == 1);
	}
}

int get_layer_map_uv_index(int layer, int map_index) {
	switch (map_index) {
		case 0:
			return layer_A_normal_map_UV_assignment * int(layer == 1) + layer_B_normal_map_UV_assignment * int(layer == 2) + layer_C_normal_map_UV_assignment * int(layer == 3);
		case 1:
			return layer_A_albedo_map_UV_assignment * int(layer == 1) + layer_B_albedo_map_UV_assignment * int(layer == 2) + layer_C_albedo_map_UV_assignment * int(layer == 3);
		case 2:
			return layer_A_occlusion_map_UV_assignment * int(layer == 1) + layer_B_occlusion_map_UV_assignment * int(layer == 2) + layer_C_occlusion_map_UV_assignment * int(layer == 3);
		case 3:
			return layer_A_roughness_map_UV_assignment * int(layer == 1) + layer_B_roughness_map_UV_assignment * int(layer == 2) + layer_C_roughness_map_UV_assignment * int(layer == 3);
		case 4:
			return layer_A_metallic_map_UV_assignment * int(layer == 1) + layer_B_metallic_map_UV_assignment * int(layer == 2) + layer_C_metallic_map_UV_assignment * int(layer == 3);
		case 5:
			return layer_A_texture_mask_A_UV_assignment * int(layer == 1) + layer_B_texture_mask_A_UV_assignment * int(layer == 2) + layer_C_texture_mask_A_UV_assignment * int(layer == 3);
		case 6:
			return layer_A_texture_mask_B_UV_assignment * int(layer == 1) + layer_B_texture_mask_B_UV_assignment * int(layer == 2) + layer_C_texture_mask_B_UV_assignment * int(layer == 3);
	}
}

int get_layer_mask_mixing_step(int layer, int mask) {
	return (layer_A_texture_masks_mixing_step * int(mask == 1) + layer_A_directional_mask_mixing_step * int(mask == 2) + layer_A_positional_mask_mixing_step * int(mask == 3) + layer_A_vertex_color_mask_mixing_step * int(mask == 4) + layer_A_vertex_color_mask_mixing_step * int(mask == 5)) * int(layer == 1) + (layer_B_texture_masks_mixing_step * int(mask == 1) + layer_B_directional_mask_mixing_step * int(mask == 2) + layer_B_positional_mask_mixing_step * int(mask == 3) + layer_B_vertex_color_mask_mixing_step * int(mask == 4) + layer_B_vertex_color_mask_mixing_step * int(mask == 5)) * int(layer == 2) + (layer_C_texture_masks_mixing_step * int(mask == 1) + layer_C_directional_mask_mixing_step * int(mask == 2) + layer_C_positional_mask_mixing_step * int(mask == 3) + layer_C_vertex_color_mask_mixing_step * int(mask == 4) + layer_C_vertex_color_mask_mixing_step * int(mask == 5)) * int(layer == 3);
}

int get_layer_step_mixing_operation(int layer, int step) {
	return (layer_A_step_2_mixing_operation * int(step == 2) + layer_A_step_3_mixing_operation * int(step == 3) + layer_A_step_4_mixing_operation * int(step == 4) + layer_A_step_5_mixing_operation * int(step == 5)) * int(layer == 1) + (layer_B_step_2_mixing_operation * int(step == 2) + layer_B_step_3_mixing_operation * int(step == 3) + layer_B_step_4_mixing_operation * int(step == 4) + layer_B_step_5_mixing_operation * int(step == 5)) * int(layer == 2) + (layer_C_step_2_mixing_operation * int(step == 2) + layer_C_step_3_mixing_operation * int(step == 3) + layer_C_step_4_mixing_operation * int(step == 4) + + layer_C_step_5_mixing_operation * int(step == 5)) * int(layer == 3);
}

float get_layer_step_mixing_threshold(int layer, int step) {
	return (layer_A_step_2_mixing_threshold * float(step == 2) + layer_A_step_3_mixing_threshold * float(step == 3) + layer_A_step_4_mixing_threshold * float(step == 4) + layer_A_step_5_mixing_threshold * float(step == 5)) * float(layer == 1) + (layer_B_step_2_mixing_threshold * float(step == 2) + layer_B_step_3_mixing_threshold * float(step == 3) + layer_B_step_4_mixing_threshold * float(step == 4) + layer_B_step_5_mixing_threshold * float(step == 5)) * float(layer == 2) + (layer_C_step_2_mixing_threshold * float(step == 2) + layer_C_step_3_mixing_threshold * float(step == 3) + layer_C_step_4_mixing_threshold * float(step == 4) + layer_C_step_5_mixing_threshold * float(step == 5)) * float(layer == 3);
}

float get_layer_mask_amplification(int layer) {
	switch (layer) {
		case 1:
			return layer_A_mask_amplification;
		case 2:
			return layer_B_mask_amplification;
		case 3:
			return layer_C_mask_amplification;
	}
}

float get_layer_mask_post_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec2 color_ramp_factor = texture(layer_A_post_color_ramp, vec2(factor, 0.0)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 2:
			vec2 color_ramp_factor = texture(layer_B_post_color_ramp, vec2(factor, 0.0)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 3:
			vec2 color_ramp_factor = texture(layer_C_post_color_ramp, vec2(factor, 0.0)).ra;
			return mix(0.0, color_ramp_factor.x, color_ramp_factor.y * factor);
	}
}

vec4 get_layer_texture_mask_texture(int layer, int a_or_b, vec2 uv) {
	switch (layer) {
		case 1:
			return (texture(layer_A_texture_mask_A, uv) * (1.0 - float(a_or_b))) + (texture(layer_A_texture_mask_B, uv) * float(a_or_b));
		case 2:
			return (texture(layer_B_texture_mask_A, uv) * (1.0 - float(a_or_b))) + (texture(layer_B_texture_mask_B, uv) * float(a_or_b));
		case 3:
			return (texture(layer_C_texture_mask_A, uv) * (1.0 - float(a_or_b))) + (texture(layer_C_texture_mask_B, uv) * float(a_or_b));
	}
}

bool get_layer_texture_mask_enabled(int layer, int a_or_b) {
	switch (layer) {
		case 1:
			return layer_A_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_A_texture_mask_B_enabled && (bool(a_or_b) == true);
		case 2:
			return layer_B_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_B_texture_mask_B_enabled && (bool(a_or_b) == true);
		case 3:
			return layer_C_texture_mask_A_enabled && (bool(a_or_b) == false) || layer_C_texture_mask_B_enabled && (bool(a_or_b) == true);
	}
}

int get_layer_texture_masks_subtraction_order(int layer) {
	switch (layer) {
		case 1:
			return layer_A_texture_masks_subtraction_order;
		case 2:
			return layer_B_texture_masks_subtraction_order;
		case 3:
			return layer_C_texture_masks_subtraction_order;
	}
}

int get_layer_texture_mask_mix_operation(int layer) {
	switch (layer) {
		case 1:
			return layer_A_texture_masks_mix_operation;
		case 2:
			return layer_B_texture_masks_mix_operation;
		case 3:
			return layer_C_texture_masks_mix_operation;
	}
}

int get_layer_directional_mask_mode(int layer) {
	switch (layer) {
		case 1:
			return layer_A_directional_mask_mode;
		case 2:
			return layer_B_directional_mask_mode;
		case 3:
			return layer_C_directional_mask_mode;
	}
}

int get_layer_directional_mask_space(int layer) {
	switch (layer) {
		case 1:
			return layer_A_directional_mask_space;
		case 2:
			return layer_B_directional_mask_space;
		case 3:
			return layer_C_directional_mask_space;
	}
}

float get_layer_directional_mask_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec2 color_ramp_factor = texture(layer_A_directional_mask_color_ramp, vec2((factor * 0.95) + 0.025)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 2:
			vec2 color_ramp_factor = texture(layer_B_directional_mask_color_ramp, vec2((factor * 0.95) + 0.025)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 3:
			vec2 color_ramp_factor = texture(layer_C_directional_mask_color_ramp, vec2((factor * 0.95) + 0.025)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
	}
}

int get_layer_positional_mask_mode(int layer) {
	switch (layer) {
		case 1:
			return layer_A_positional_mask_mode;
		case 2:
			return layer_B_positional_mask_mode;
		case 3:
			return layer_C_positional_mask_mode;
	}
}

int get_layer_positional_mask_axis(int layer) {
	switch (layer) {
		case 1:
			return layer_A_positional_mask_axis;
		case 2:
			return layer_B_positional_mask_axis;
		case 3:
			return layer_C_positional_mask_axis;
	}
}

float get_layer_positional_mask_min(int layer) {
	switch (layer) {
		case 1:
			return layer_A_positional_mask_min;
		case 2:
			return layer_B_positional_mask_min;
		case 3:
			return layer_C_positional_mask_min;
	}
}

float get_layer_positional_mask_max(int layer) {
	switch (layer) {
		case 1:
			return layer_A_positional_mask_max;
		case 2:
			return layer_B_positional_mask_max;
		case 3:
			return layer_C_positional_mask_max;
	}
}

float get_layer_positional_mask_color_ramp_value(int layer, float factor) {
	switch (layer) {
		case 1:
			vec2 color_ramp_factor = texture(layer_A_positional_mask_color_ramp, vec2(factor, 0.0)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 2:
			vec2 color_ramp_factor = texture(layer_B_positional_mask_color_ramp, vec2(factor, 0.0)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
		case 3:
			vec2 color_ramp_factor = texture(layer_C_positional_mask_color_ramp, vec2(factor, 0.0)).ra;
			return mix(factor, color_ramp_factor.x, color_ramp_factor.y);
	}
}

bool get_layer_normal_map_slope_mask_enabled(int layer) {
	switch (layer) {
		case 1:
			return layer_A_normal_map_slope_mask_enabled;
		case 2:
			return layer_B_normal_map_slope_mask_enabled;
		case 3:
			return layer_C_normal_map_slope_mask_enabled;
	}
}

//======================================================================




float get_texture_mask_for_layer(int layer, vec2 uv) {
	float texture_mask_mix;

	vec4 texture_mask_A_texture = get_layer_texture_mask_texture(layer, 0, uv);
	vec4 texture_mask_B_texture = get_layer_texture_mask_texture(layer, 1, uv);

	int texture_masks_subtraction_order = get_layer_texture_masks_subtraction_order(layer);

	bool texture_mask_A_enabled = get_layer_texture_mask_enabled(layer, 0);
	bool texture_mask_B_enabled = get_layer_texture_mask_enabled(layer, 1);

	switch (get_layer_texture_mask_mix_operation(layer)) {
		case 0:
			texture_mask_mix = (texture_mask_A_texture.r * texture_mask_A_texture.a * float(texture_mask_A_enabled)) + (texture_mask_B_texture.r * texture_mask_B_texture.a * float(texture_mask_B_enabled));
			break;
		case 1:
			switch (texture_masks_subtraction_order) {
				case 0:
					texture_mask_mix = (texture_mask_A_texture.r * texture_mask_A_texture.a * float(texture_mask_A_enabled)) - (texture_mask_B_texture.r * texture_mask_B_texture.a * float(texture_mask_B_enabled));
					break;
				case 1:
					texture_mask_mix = (texture_mask_B_texture.r * texture_mask_B_texture.a * float(texture_mask_B_enabled)) - (texture_mask_A_texture.r * texture_mask_A_texture.a * float(texture_mask_A_enabled));
					break;
			}
			break;
		case 2:
			texture_mask_mix = texture_mask_A_texture.r * texture_mask_B_texture.r;
			break;
	}

	return texture_mask_mix;
}

float get_directional_mask_for_layer(int layer, vec3 local_surface_normal, vec3 global_surface_normal) {
		vec3 surface_normal = local_surface_normal * float(get_layer_directional_mask_space(layer) == 1) + global_surface_normal * float(get_layer_directional_mask_space(layer) == 0);
		switch (get_layer_directional_mask_mode(layer)) {
			case 0:
				return 0.0;
			case 1:
				return (abs(surface_normal.r) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.r)));
			case 2:
				return (clamp(surface_normal.r, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.r, 0.0, 1.0)));
			case 3:
				return (abs(clamp(surface_normal.r, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.r, -1.0, 0.0))));
			case 4:
				return (abs(surface_normal.g) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.g)));
			case 5:
				return (clamp(surface_normal.g, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.g, 0.0, 1.0)));
			case 6:
				return (abs(clamp(surface_normal.g, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.g, -1.0, 0.0))));
			case 7:
				return (abs(surface_normal.b) * get_layer_directional_mask_color_ramp_value(layer, abs(surface_normal.b)));
			case 8:
				return (clamp(surface_normal.b, 0.0, 1.0) * get_layer_directional_mask_color_ramp_value(layer, clamp(surface_normal.b, 0.0, 1.0)));
			case 9:
				return (abs(clamp(surface_normal.b, -1.0, 0.0)) * get_layer_directional_mask_color_ramp_value(layer, abs(clamp(surface_normal.b, -1.0, 0.0))));
			}
}

float get_positional_mask_for_layer(int layer, vec3 local_v_position, vec3 global_v_position) {
	float positional_mask_value;
	float positional_mask_max = get_layer_positional_mask_max(layer);
	float positional_mask_min = get_layer_positional_mask_min(layer);

	vec3 v_position = (float(get_layer_positional_mask_mode(layer) == 1) * local_v_position) + (float(get_layer_positional_mask_mode(layer) == 2) * global_v_position);

	switch (get_layer_positional_mask_axis(layer)) {
			case 0:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.x + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
				return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0);
			case 1:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.y + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
				return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0);
			case 2:
				positional_mask_value = clamp(1.0/(positional_mask_max - positional_mask_min) * v_position.z + (1.0 - 1.0/(positional_mask_max - positional_mask_min) * positional_mask_max), 0.002, 0.998);
				return get_layer_positional_mask_color_ramp_value(layer, positional_mask_value) * float(get_layer_positional_mask_mode(layer) != 0);
		}
}

float get_vertex_color_mask_for_layer(int layer) {
	switch (layer) {
		case 1:
			switch (layer_A_vertex_color_mask_mode) {
				case 0:
					return 0.0;
				case 1:
					return texture(layer_A_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.r, 0.005, 0.995), 0.0)).r * texture(layer_A_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.r, 0.0, 1.0) * vertex_color.r, 0.0)).a;
				case 2:
					return texture(layer_A_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.g, 0.005, 0.995), 0.0)).r * texture(layer_A_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.g, 0.0, 1.0) * vertex_color.g, 0.0)).a;
				case 3:
					return texture(layer_A_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.b, 0.005, 0.995), 0.0)).r * texture(layer_A_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.b, 0.0, 1.0) * vertex_color.b, 0.0)).a;
			}
		case 2:
			switch (layer_B_vertex_color_mask_mode) {
				case 0:
					return 0.0;
				case 1:
					return texture(layer_B_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.r, 0.0, 1.0) * vertex_color.r, 0.0)).r;
				case 2:
					return texture(layer_B_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.g, 0.0, 1.0) * vertex_color.g, 0.0)).r;
				case 3:
					return texture(layer_B_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.b, 0.0, 1.0) * vertex_color.b, 0.0)).r;
			}
		case 3:
			switch (layer_C_vertex_color_mask_mode) {
				case 0:
					return 0.0;
				case 1:
					return texture(layer_C_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.r, 0.0, 1.0) * vertex_color.r, 0.0)).r;
				case 2:
					return texture(layer_C_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.g, 0.0, 1.0) * vertex_color.g, 0.0)).r;
				case 3:
					return texture(layer_C_vertex_color_mask_color_ramp, vec2(clamp(vertex_color.b, 0.0, 1.0) * vertex_color.b, 0.0)).r;
			}

	};
}

float get_resulting_mask_for_layer(int layer, vec2 uv, vec3 local_surface_normal, vec3 global_surface_normal, vec3 local_vertex_position, vec3 global_vertex_position, int mask_A_uv_map_index, int mask_B_uv_map_index) {
	float step_1_mix = clamp((get_texture_mask_for_layer(layer, uv) * float(get_layer_mask_mixing_step(layer, 1) == 1) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == 1) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == 1) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == 1)), 0.0, 1.0);

	float step_2_mix = clamp((get_texture_mask_for_layer(layer, uv) * float(get_layer_mask_mixing_step(layer, 1) == 2) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == 2) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == 2) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == 2)), 0.0, 1.0);
	switch (get_layer_step_mixing_operation(layer, 2)) {
		case 0:
			step_2_mix = clamp(step_1_mix + (step_2_mix * float(step_1_mix >= get_layer_step_mixing_threshold(layer, 2))), 0.0, 1.0);
			break;
		case 1:
			step_2_mix = clamp(step_1_mix - (step_2_mix * float(step_1_mix >= get_layer_step_mixing_threshold(layer, 2))), 0.0, 1.0);
			break;
		case 2:
			if (step_1_mix >= get_layer_step_mixing_threshold(layer, 4)) {
				step_2_mix = clamp(step_1_mix * step_2_mix, 0.0, 1.0);
			}
			else {
				step_2_mix = step_1_mix;
				}
			break;
	}

	float step_3_mix = clamp((get_texture_mask_for_layer(layer, uv) * float(get_layer_mask_mixing_step(layer, 1) == 3) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == 3) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == 3) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == 3)), 0.0, 1.0);
	switch (get_layer_step_mixing_operation(layer, 3)) {
		case 0:
			step_3_mix = clamp(step_2_mix + (step_3_mix * float(step_2_mix >= get_layer_step_mixing_threshold(layer, 3))), 0.0, 1.0);
			break;
		case 1:
			step_3_mix = clamp(step_2_mix - (step_3_mix * float(step_2_mix >= get_layer_step_mixing_threshold(layer, 3))), 0.0, 1.0);
			break;
		case 2:
			if (step_2_mix >= get_layer_step_mixing_threshold(layer, 4)) {
				step_3_mix = clamp(step_2_mix * step_3_mix, 0.0, 1.0);
			}
			else {
				step_3_mix = step_2_mix;
				}
			break;
	}

	float step_4_mix = clamp((get_texture_mask_for_layer(layer, uv) * float(get_layer_mask_mixing_step(layer, 1) == 4) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == 4) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == 4) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == 4)), 0.0, 1.0);
	switch (get_layer_step_mixing_operation(layer, 4)) {
		case 0:
			step_4_mix = clamp(step_3_mix + (step_4_mix * float(step_3_mix >= get_layer_step_mixing_threshold(layer, 4))), 0.0, 1.0);
			break;
		case 1:
			step_4_mix = clamp(step_3_mix - (step_4_mix * float(step_3_mix >= get_layer_step_mixing_threshold(layer, 4))), 0.0, 1.0);
			break;
		case 2:
			if (step_3_mix >= get_layer_step_mixing_threshold(layer, 4)) {
				step_4_mix = clamp(step_3_mix * step_4_mix, 0.0, 1.0);
			}
			else {
				step_4_mix = step_3_mix;
				}
			break;
	}

	float step_5_mix = clamp((get_texture_mask_for_layer(layer, uv) * float(get_layer_mask_mixing_step(layer, 1) == 5) + get_directional_mask_for_layer(layer, local_surface_normal, global_surface_normal) * float(get_layer_mask_mixing_step(layer, 2) == 5) + get_positional_mask_for_layer(layer, local_vertex_position, global_vertex_position) * float(get_layer_mask_mixing_step(layer, 3) == 5) + get_vertex_color_mask_for_layer(layer) * float(get_layer_mask_mixing_step(layer, 4) == 5)), 0.0, 1.0);
	switch (get_layer_step_mixing_operation(layer, 5)) {
		case 0:
			step_5_mix = clamp(step_4_mix + (step_5_mix * float(step_4_mix >= get_layer_step_mixing_threshold(layer, 5))), 0.0, 1.0);
			break;
		case 1:
			step_5_mix = clamp(step_4_mix - (step_5_mix * float(step_4_mix >= get_layer_step_mixing_threshold(layer, 5))), 0.0, 1.0);
			break;
		case 2:
			if (step_4_mix >= get_layer_step_mixing_threshold(layer, 5)) {
				step_4_mix = clamp(step_4_mix * step_5_mix, 0.0, 1.0);
			}
			else {
				step_5_mix = step_4_mix;
				}
			break;
	}

	//return step_3_mix;
	return get_layer_mask_post_color_ramp_value(layer, clamp(step_5_mix, 0.0, 1.0) * get_layer_mask_amplification(layer) * 0.9 + 0.02);
}

void vertex() {
	switch (vertex_displacement_mode) {
		case 1:
			VERTEX.xyz += NORMAL.xyz * vertex_displacement_scale * texture(vertex_displacement_map, UV).r;
			break;
	}
	local_vertex_normal = NORMAL.rgb;
	global_vertex_normal = local_vertex_normal * MODEL_NORMAL_MATRIX;
	local_vertex_pos = VERTEX.xyz;
	global_vertex_pos = (vec4(local_vertex_normal, 1.0) * MODEL_MATRIX).xyz;
}

void fragment() {
	vertex_color = COLOR.rgb;

	vec3 underlying_albedo = texture(screen_texture, SCREEN_UV).rgb;
	vec3 albedo_mix = underlying_albedo;
	//vec3 albedo_mix = layer_base_albedo_texture.rgb;
	float occlusion_mix = 0.0;
	float roughness_mix = 0.0;
	float metallic_mix = 0.0;
	//vec3 normal_mix = vec3(0.0, 0.0, 0.0);

	//bool layer_index_1_enabled = get_layer_processing_index

	int layer_1_assigned_layer = get_processing_layer_assigned_layer(1);
	int layer_2_assigned_layer = get_processing_layer_assigned_layer(2);
	int layer_3_assigned_layer = get_processing_layer_assigned_layer(3);

	if (layer_A_enabled == true) {
		vec2 uv1 = (UV + get_layer_uv_offset(1, 0, UV) + layer_A_uv1_offset) * layer_A_uv1_scale;
		vec2 uv2 = (UV + get_layer_uv_offset(1, 1, UV) + layer_A_uv2_offset) * layer_A_uv2_scale;

		int layer_A_normal_uv_map_index = get_layer_map_uv_index(1,0);
		int layer_A_albedo_uv_map_index = get_layer_map_uv_index(1,1);
		int layer_A_occlusion_uv_map_index = get_layer_map_uv_index(1,2);
		int layer_A_roughness_uv_map_index = get_layer_map_uv_index(1,3);
		int layer_A_metallic_uv_map_index = get_layer_map_uv_index(1,4);

		vec4 layer_A_albedo_texture = texture(layer_A_albedo, uv1 * float(layer_A_albedo_uv_map_index == 0) + uv2 * float(layer_A_albedo_uv_map_index == 1));
		vec2 layer_A_occlusion_factor = texture(layer_A_occlusion_map, uv1 * float(layer_A_occlusion_uv_map_index == 0) + uv2 * float(layer_A_occlusion_uv_map_index == 1)).ra * float(layer_A_orm_mode) + texture(layer_A_orm_map, uv1 * float(layer_A_occlusion_uv_map_index == 0) + uv2 * float(layer_A_occlusion_uv_map_index == 1)).ra * (1.0 - float(layer_A_orm_mode));
		vec2 layer_A_roughness_factor = texture(layer_A_roughness_map, uv1 * float(layer_A_roughness_uv_map_index == 0) + uv2 * float(layer_A_roughness_uv_map_index == 1)).ra * float(layer_A_orm_mode) + texture(layer_A_orm_map, uv1 * float(layer_A_roughness_uv_map_index == 0) + uv2 * float(layer_A_roughness_uv_map_index == 1)).ga * (1.0 - float(layer_A_orm_mode));
		vec2 layer_A_metallic_factor = texture(layer_A_metallic_map, uv1 * float(layer_A_metallic_uv_map_index == 0) + uv2 * float(layer_A_metallic_uv_map_index == 1)).ra * float(layer_A_orm_mode) + texture(layer_A_orm_map, uv1 * float(layer_A_metallic_uv_map_index == 0) + uv2 * float(layer_A_metallic_uv_map_index == 1)).ra * (1.0 - float(layer_A_orm_mode));
		vec3 layer_A_normal_texture = texture(layer_A_normal, uv1 * float(layer_A_normal_uv_map_index == 0) + uv2 * float(layer_A_normal_uv_map_index == 1)).rgb;

		int mask_A_uv_map_index = get_layer_map_uv_index(1, 5);
		int mask_B_uv_map_index = get_layer_map_uv_index(1, 6);

		float layer_A_mask_factor = get_resulting_mask_for_layer(1, (UV + layer_A_mask_uv_offset) * layer_A_mask_uv_scale, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos, mask_A_uv_map_index, mask_B_uv_map_index);
		albedo_mix = mix(albedo_mix, layer_A_albedo_texture.rgb, layer_A_mask_factor * layer_A_albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(layer_A_mask_factor), float(layer_A_consolidate_masks));

		occlusion_mix = mix(occlusion_mix, layer_A_occlusion_factor.x, layer_A_mask_factor * layer_A_occlusion_factor.y);
		roughness_mix = mix(roughness_mix, layer_A_roughness_factor.x, layer_A_mask_factor * layer_A_roughness_factor.y);
		metallic_mix = mix(metallic_mix, layer_A_metallic_factor.x, layer_A_mask_factor * layer_A_metallic_factor.y);
		//normal_mix = mix(normal_mix, layer_A_normal_texture, layer_A_mask_factor * (1.0 - float(layer_A_propagate_normals)));
	}

	if (layer_B_enabled == true) {
		vec2 uv1 = (UV + get_layer_uv_offset(2, 0, UV) + layer_B_uv1_offset) * layer_B_uv1_scale;
		vec2 uv2 = (UV + get_layer_uv_offset(2, 1, UV) + layer_B_uv2_offset) * layer_B_uv2_scale;

		int layer_B_normal_uv_map_index = get_layer_map_uv_index(2,0);
		int layer_B_albedo_uv_map_index = get_layer_map_uv_index(2,1);
		int layer_B_occlusion_uv_map_index = get_layer_map_uv_index(2,2);
		int layer_B_roughness_uv_map_index = get_layer_map_uv_index(2,3);
		int layer_B_metallic_uv_map_index = get_layer_map_uv_index(2,4);

		vec4 layer_B_albedo_texture = texture(layer_B_albedo, uv1 * float(layer_B_albedo_uv_map_index == 0) + uv2 * float(layer_B_albedo_uv_map_index == 1));
		vec2 layer_B_occlusion_factor = texture(layer_B_occlusion_map, uv1 * float(layer_B_occlusion_uv_map_index == 0) + uv2 * float(layer_B_occlusion_uv_map_index == 1)).ra * float(layer_B_orm_mode) + texture(layer_B_orm_map, uv1 * float(layer_B_occlusion_uv_map_index == 0) + uv2 * float(layer_B_occlusion_uv_map_index == 1)).ra * (1.0 - float(layer_B_orm_mode));
		vec2 layer_B_roughness_factor = texture(layer_B_roughness_map, uv1 * float(layer_B_roughness_uv_map_index == 0) + uv2 * float(layer_B_roughness_uv_map_index == 1)).ra * float(layer_B_orm_mode) + texture(layer_B_orm_map, uv1 * float(layer_B_roughness_uv_map_index == 0) + uv2 * float(layer_B_roughness_uv_map_index == 1)).ga * (1.0 - float(layer_B_orm_mode));
		vec2 layer_B_metallic_factor = texture(layer_B_metallic_map, uv1 * float(layer_B_metallic_uv_map_index == 0) + uv2 * float(layer_B_metallic_uv_map_index == 1)).ra * float(layer_B_orm_mode) + texture(layer_B_orm_map, uv1 * float(layer_B_metallic_uv_map_index == 0) + uv2 * float(layer_B_metallic_uv_map_index == 1)).ra * (1.0 - float(layer_B_orm_mode));
		vec3 layer_B_normal_texture = texture(layer_B_normal, uv1 * float(layer_B_normal_uv_map_index == 0) + uv2 * float(layer_B_normal_uv_map_index == 1)).rgb;

		int mask_A_uv_map_index = get_layer_map_uv_index(2, 5);
		int mask_B_uv_map_index = get_layer_map_uv_index(2, 6);

		float layer_B_mask_factor = get_resulting_mask_for_layer(2, (UV + layer_B_mask_uv_offset) * layer_B_mask_uv_scale, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos, mask_A_uv_map_index, mask_B_uv_map_index);
		albedo_mix = mix(albedo_mix, layer_B_albedo_texture.rgb, layer_B_mask_factor * layer_B_albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(layer_B_mask_factor), float(layer_B_consolidate_masks));

		occlusion_mix = mix(occlusion_mix, layer_B_occlusion_factor.x, layer_B_mask_factor * layer_B_occlusion_factor.y);
		roughness_mix = mix(roughness_mix, layer_B_roughness_factor.x, layer_B_mask_factor * layer_B_roughness_factor.y);
		metallic_mix = mix(metallic_mix, layer_B_metallic_factor.x, layer_B_mask_factor * layer_B_metallic_factor.y);
		//normal_mix = mix(normal_mix, layer_B_normal_texture, layer_B_mask_factor * (1.0 - float(layer_B_propagate_normals)));
	}

	if (layer_C_enabled == true) {
		vec2 uv1 = (UV + get_layer_uv_offset(3, 0, UV) + layer_C_uv1_offset) * layer_C_uv1_scale;
		vec2 uv2 = (UV + get_layer_uv_offset(3, 1, UV) + layer_C_uv2_offset) * layer_C_uv2_scale;

		int layer_C_normal_uv_map_index = get_layer_map_uv_index(2,0);
		int layer_C_albedo_uv_map_index = get_layer_map_uv_index(2,1);
		int layer_C_occlusion_uv_map_index = get_layer_map_uv_index(2,2);
		int layer_C_roughness_uv_map_index = get_layer_map_uv_index(2,3);
		int layer_C_metallic_uv_map_index = get_layer_map_uv_index(2,4);

		vec4 layer_C_albedo_texture = texture(layer_C_albedo, uv1 * float(layer_C_albedo_uv_map_index == 0) + uv2 * float(layer_C_albedo_uv_map_index == 1));
		vec2 layer_C_occlusion_factor = texture(layer_C_occlusion_map, uv1 * float(layer_C_occlusion_uv_map_index == 0) + uv2 * float(layer_C_occlusion_uv_map_index == 1)).ra * float(layer_C_orm_mode) + texture(layer_C_orm_map, uv1 * float(layer_C_occlusion_uv_map_index == 0) + uv2 * float(layer_C_occlusion_uv_map_index == 1)).ra * (1.0 - float(layer_C_orm_mode));
		vec2 layer_C_roughness_factor = texture(layer_C_roughness_map, uv1 * float(layer_C_roughness_uv_map_index == 0) + uv2 * float(layer_C_roughness_uv_map_index == 1)).ra * float(layer_C_orm_mode) + texture(layer_C_orm_map, uv1 * float(layer_C_roughness_uv_map_index == 0) + uv2 * float(layer_C_roughness_uv_map_index == 1)).ga * (1.0 - float(layer_C_orm_mode));
		vec2 layer_C_metallic_factor = texture(layer_C_metallic_map, uv1 * float(layer_C_metallic_uv_map_index == 0) + uv2 * float(layer_C_metallic_uv_map_index == 1)).ra * float(layer_C_orm_mode) + texture(layer_C_orm_map, uv1 * float(layer_C_metallic_uv_map_index == 0) + uv2 * float(layer_C_metallic_uv_map_index == 1)).ra * (1.0 - float(layer_C_orm_mode));
		vec3 layer_C_normal_texture = texture(layer_C_normal, uv1 * float(layer_C_normal_uv_map_index == 0) + uv2 * float(layer_C_normal_uv_map_index == 1)).rgb;

		int mask_A_uv_map_index = get_layer_map_uv_index(3, 5);
		int mask_B_uv_map_index = get_layer_map_uv_index(3, 6);

		float layer_C_mask_factor = get_resulting_mask_for_layer(3, (UV + layer_C_mask_uv_offset) * layer_C_mask_uv_scale, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos, mask_A_uv_map_index, mask_B_uv_map_index);
		albedo_mix = mix(albedo_mix, layer_C_albedo_texture.rgb, layer_C_mask_factor * layer_C_albedo_texture.a);
		albedo_mix = mix(albedo_mix, vec3(layer_C_mask_factor), float(layer_C_consolidate_masks));

		occlusion_mix = mix(occlusion_mix, layer_C_occlusion_factor.x, layer_C_mask_factor * layer_C_occlusion_factor.y);
		roughness_mix = mix(roughness_mix, layer_C_roughness_factor.x, layer_C_mask_factor * layer_C_roughness_factor.y);
		metallic_mix = mix(metallic_mix, layer_C_metallic_factor.x, layer_C_mask_factor * layer_C_metallic_factor.y);
		//normal_mix = mix(normal_mix, layer_C_normal_texture, layer_C_mask_factor * (1.0 - float(layer_C_propagate_normals)));
	}

	ALBEDO = albedo_mix.rgb;
	//ALBEDO = vec3(get_positional_mask_for_layer(1, local_vertex_pos, global_vertex_pos));
	//ALBEDO = vec3(get_directional_mask_for_layer(1, local_vertex_normal, global_vertex_normal));
	//ALBEDO = vec3(get_resulting_mask_for_layer(1, UV, local_vertex_normal, global_vertex_normal, local_vertex_pos, global_vertex_pos));
	//ALBEDO = vec3(get_vertex_color_mask_for_layer(1));
	ROUGHNESS = roughness_mix;
	METALLIC = metallic_mix;
	
	//if (normal_mix != vec3(0.0, 0.0, 0.0)) {
		//NORMAL_MAP = normal_mix;
	//}
	//ALBEDO = global_vertex_normal.rgb;
	//ALPHA = 1.0;
}